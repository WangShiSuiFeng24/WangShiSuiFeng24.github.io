{"meta":{"title":"往事丶随风的博客","subtitle":"我是子标题","description":"华中师范大学 计算机应用技术专业","author":"AndongMing","url":"http://example.com","root":"/"},"pages":[{"title":"分类","date":"2023-08-27T01:12:22.000Z","updated":"2023-08-27T01:13:15.183Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-08-27T01:15:40.000Z","updated":"2023-08-27T01:16:18.054Z","comments":true,"path":"link/index.html","permalink":"http://example.com/link/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-08-27T01:09:37.000Z","updated":"2023-08-27T01:11:01.492Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"指派问题","slug":"指派问题","date":"2024-09-21T09:08:10.000Z","updated":"2024-09-21T10:25:23.971Z","comments":true,"path":"2024/09/21/指派问题/","link":"","permalink":"http://example.com/2024/09/21/%E6%8C%87%E6%B4%BE%E9%97%AE%E9%A2%98/","excerpt":"","text":"问题描述 描述 分配工作 甲、乙、丙、丁4人都能完成A、B、C、D4项工作，但是甲、乙、丙、丁4人做这4项工作的价值不同。给甲、乙、丙、丁分配工作时，每人能且仅能分配一项工作，每项工作有且仅有一人做，如何分配工作，才能使总价值最大。 工作价值表： A B C D 甲 4 4 1 3 乙 8 5 4 6 丙 4 3 9 5 丁 6 2 8 1 最大总价值25 人数和工作数都是n时，如何给n人分配n项工作，才能使n人完成n项工作的总价值最大 输入 n+1行，第1行是正整数n（小于10），第2到第n+1行是n个人的工作价值表。 输出 输出一个整数，表示最大总价值。 样例输入 1234549 3 3 82 7 5 97 5 9 59 7 6 8 样例输出 134 原题链接 http://gxdd.openjudge.cn/code18/1155/ 解题思路 排列解法 排列解法主要思路 可将此类问题视为排列问题，从 {0,1,...,n−1}\\{0, 1, ... , n-1\\}{0,1,...,n−1} 开始，枚举所有排列，下标表示行，对应值表示列 时间复杂度 O(n!)O(n!)O(n!) 代码（排列解法） 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; vector&lt;vector&lt;int&gt;&gt; a; int n; scanf(&quot;%d&quot;, &amp;n); vector&lt;int&gt; tmp; int x; for (int r = 0; r &lt; n; ++r) &#123; tmp.clear(); for (int c = 0; c &lt; n; ++c) &#123; scanf(&quot;%d&quot;, &amp;x); tmp.push_back(x); &#125; a.push_back(tmp); &#125; vector&lt;int&gt; cols(n); for (int c = 0; c &lt; n; ++c) cols[c] = c; int max_sum = 0; do &#123; int sum = 0; for (int row = 0; row &lt; n; ++row) &#123; int col = cols[row]; sum += a[row][col]; &#125; if (sum &gt; max_sum) max_sum = sum; &#125; while (next_permutation(cols.begin(), cols.end())); printf(&quot;%d\\n&quot;, max_sum); return 0;&#125; 匈牙利算法 匈牙利算法主要思想 通过不同形式的加法和减法变换矩阵，使得变换后的矩阵不影响最终位置的选择，从而也不影响最终需要的最大值或最小值。 代码（匈牙利算法） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219#include &lt;cstdio&gt;#include &lt;climits&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;algorithm&gt;using namespace std;// 输入数据int n;vector&lt;vector&lt;int&gt;&gt; a;// tmp是矩阵a的拷贝，匈牙利算法变换的矩阵为该矩阵vector&lt;vector&lt;int&gt;&gt; tmp;// row_set, col_set 分别存储行和列的被划线集合set&lt;int&gt; row_set, col_set;// 输出// ans_set 存储最终选择的位置集合set&lt;pair&lt;int, int&gt;&gt; ans_set;void pre_process();void step_1();void step_2();void step_3();int main()&#123; // 输入 scanf(&quot;%d&quot;, &amp;n); int val; vector&lt;int&gt; tmp_row; for (int r = 0; r &lt; n; ++r) &#123; tmp_row.clear(); for (int c = 0; c &lt; n; ++c) scanf(&quot;%d&quot;, &amp;val), tmp_row.push_back(val); a.push_back(tmp_row); &#125; // 拷贝矩阵a，匈牙利算变换的矩阵为tmp tmp = a; pre_process(); step_1(); // 循环 直到行和列的划线集合个数之和 &gt;= n while (1) &#123; step_2(); if (row_set.size() + col_set.size() &gt;= n) break; step_3(); &#125; // 准备输出 row_set.clear(); col_set.clear(); ans_set.clear(); // step_2 会顺便将 ans_set 填充 step_2(); // 将选择的位置处的值相加 int ans = 0; for (const auto &amp;p : ans_set) ans += a[p.first][p.second]; // 输出 printf(&quot;%d\\n&quot;, ans); return 0;&#125;// 预处理// 【匈牙利算法 本来是求最小值的】// 将拷贝后的矩阵tmp 每个元素 取相反数// 取反相反数后的tmp 每个元素 减去 tmp所有元素中的最小值, 使得元素值都 &gt;=0// 则【将 求最大值 转化为 求最小值】// 若 题目 求最小值，可跳过 此步骤void pre_process()&#123; int min_val = 0; // 对矩阵tmp 每个元素取相反数，同时 找到矩阵tmp 中最小值 for (int r = 0; r &lt; n; ++r) for (int c = 0; c &lt; n; ++c) &#123; tmp[r][c] = -a[r][c]; if (tmp[r][c] &lt; min_val) min_val = tmp[r][c]; &#125; // 矩阵tmp 每个元素减去 最小值，使得元素值都 &gt;=0 for (int r = 0; r &lt; n; ++r) for (int c = 0; c &lt; n; ++c) tmp[r][c] -= min_val;&#125;// 【第一步，依次减去行和列的最小值】void step_1()&#123; // row_min, col_min 分别存储每行和每列的最小值 vector&lt;int&gt; row_min(n), col_min(n); for (int r = 0; r &lt; n; ++r) row_min[r] = *min_element(tmp[r].begin(), tmp[r].end()); // 每行减去 行中最小值 for (int r = 0; r &lt; n; ++r) for (int c = 0; c &lt; n; ++c) tmp[r][c] -= row_min[r]; for (int c = 0; c &lt; n; ++c) &#123; col_min[c] = tmp[0][c]; for (int r = 1; r &lt; n; ++r) col_min[c] = min(col_min[c], tmp[r][c]); &#125; // 每列减去 列中最小值 for (int r = 0; r &lt; n; ++r) for (int c = 0; c &lt; n; ++c) &#123; tmp[r][c] -= col_min[c]; &#125;&#125;// 【第二步，行有独立划掉列，列有独立划掉行】// 这里的独立是指 有且仅有一个0// 划掉的行列分别 放入 row_set 和 col_set// 被划掉的0不计数void step_2()&#123; row_set.clear(); col_set.clear(); // 循环 直到没有独立的行或列 while (1) &#123; bool completed = true; // 行有独立划掉列 // 被划掉的0不计数 for (int r = 0; r &lt; n; ++r) &#123; if (row_set.count(r)) continue; int cnt = 0; int tmp_c; for (int c = 0; c &lt; n; ++c) &#123; if (!col_set.count(c) &amp;&amp; tmp[r][c] == 0) ++cnt, tmp_c = c; if (cnt &gt; 1) break; &#125; if (cnt == 1) &#123; col_set.insert(tmp_c), completed = false; // 顺便将 ans_set 填充 ans_set.insert(&#123;r, tmp_c&#125;); &#125; &#125; // 列有独立划掉行 // 被划掉的0不计数 for (int c = 0; c &lt; n; ++c) &#123; if (col_set.count(c)) continue; int cnt = 0; int tmp_r; for (int r = 0; r &lt; n; ++r) &#123; if (!row_set.count(r) &amp;&amp; tmp[r][c] == 0) ++cnt, tmp_r = r; if (cnt &gt; 1) break; &#125; if (cnt == 1) &#123; row_set.insert(tmp_r), completed = false; // 顺便将 ans_set 填充 ans_set.insert(&#123;tmp_r, c&#125;); &#125; &#125; // 没有独立的行或列，跳出循环 if (completed) break; &#125;&#125;// 【第三步，把剩下部分的数字减去其中的min，对划线交叉的数字加上min】void step_3()&#123; int min_value = INT_MAX; // 找到所有未划掉的数字的最小值 for (int r = 0; r &lt; n; ++r) for (int c = 0; c &lt; n; ++c) &#123; if (!row_set.count(r) &amp;&amp; !col_set.count(c) &amp;&amp; tmp[r][c] &lt; min_value) min_value = tmp[r][c]; &#125; // 减去最小值，加上最小值 for (int r = 0; r &lt; n; ++r) for (int c = 0; c &lt; n; ++c) &#123; if (!row_set.count(r) &amp;&amp; !col_set.count(c)) tmp[r][c] -= min_value; if (row_set.count(r) &amp;&amp; col_set.count(c)) tmp[r][c] += min_value; &#125;&#125;","categories":[],"tags":[]},{"title":"P1990 覆盖墙壁","slug":"P1990-覆盖墙壁","date":"2024-09-07T02:39:08.000Z","updated":"2024-09-07T03:05:59.157Z","comments":true,"path":"2024/09/07/P1990-覆盖墙壁/","link":"","permalink":"http://example.com/2024/09/07/P1990-%E8%A6%86%E7%9B%96%E5%A2%99%E5%A3%81/","excerpt":"","text":"题目 洛谷P1990 覆盖墙壁 思路1 b站涂老师的视频 核心递推方程： f(n)=f(n−1)+f(n−2)+2g(n−1)g(n)=f(n−2)+g(n−1)f(n) = f(n-1) + f(n-2) + 2g(n-1)\\\\ g(n) = f(n-2) + g(n-1) f(n)=f(n−1)+f(n−2)+2g(n−1)g(n)=f(n−2)+g(n−1) 思路2 洛谷某网友玄学题解 核心递推方程： f(n)=2f(n−1)+f(n−3)f(n) = 2f(n-1) + f(n-3) f(n)=2f(n−1)+f(n−3) 思路1到思路2方程的推导过程 思路1第一个方程 f(n)=f(n−1)+f(n−2)+2g(n−1)f(n) = f(n-1) + f(n-2) + 2g(n-1) f(n)=f(n−1)+f(n−2)+2g(n−1) 将 n−1n-1n−1 带入上式 f(n−1)=f(n−2)+f(n−3)+2g(n−2)f(n-1) = f(n-2) + f(n-3) + 2g(n-2) f(n−1)=f(n−2)+f(n−3)+2g(n−2) 将上面第一个式子减第二个式子 f(n)−f(n−1)=f(n−1)−f(n−3)+2(g(n−1)−g(n−2))f(n) - f(n-1) = f(n-1) - f(n-3) + 2(g(n-1) - g(n-2)) f(n)−f(n−1)=f(n−1)−f(n−3)+2(g(n−1)−g(n−2)) 将 n−1n-1n−1 带入思路1的第二个方程 g(n−1)=f(n−3)+g(n−2)⇒g(n−1)−g(n−2)=f(n−3)g(n-1) = f(n-3) + g(n-2) \\\\ \\Rightarrow g(n-1) - g(n-2) = f(n-3) g(n−1)=f(n−3)+g(n−2)⇒g(n−1)−g(n−2)=f(n−3) 所以经推导可得思路2的方程 f(n)−f(n−1)=f(n−1)−f(n−3)+2f(n−3)⇒f(n)=2f(n−1)+f(n−3)f(n) - f(n-1) = f(n-1) - f(n-3) + 2f(n-3) \\\\ \\Rightarrow f(n) = 2f(n-1) + f(n-3) f(n)−f(n−1)=f(n−1)−f(n−3)+2f(n−3)⇒f(n)=2f(n−1)+f(n−3)","categories":[],"tags":[]},{"title":"让hexo支持latex数学公式","slug":"让hexo支持latex数学公式","date":"2024-09-05T10:40:39.000Z","updated":"2024-09-05T10:55:28.752Z","comments":true,"path":"2024/09/05/让hexo支持latex数学公式/","link":"","permalink":"http://example.com/2024/09/05/%E8%AE%A9hexo%E6%94%AF%E6%8C%81latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/","excerpt":"","text":"流程 卸载原来的渲染器 1npm un hexo-renderer-marked 安装新的渲染器 1npm i hexo-renderer-markdown-it-katex 修改配置文件, 在_config.yml文件末尾添加如下内容 1234567891011markdown: render: html: true xhtmlOut: false breaks: true linkify: true typographer: true plugins: anchors: level: 1 collisionSuffix: &#x27;&#x27; 参考链接 https://nickxu.me/2022/04/17/Hexo-Butterfly-建站指南（八）使用-KaTeX-数学公式/","categories":[],"tags":[]},{"title":"卡特兰数","slug":"卡特兰数","date":"2024-09-05T01:25:18.000Z","updated":"2024-09-05T10:37:50.316Z","comments":true,"path":"2024/09/05/卡特兰数/","link":"","permalink":"http://example.com/2024/09/05/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/","excerpt":"","text":"基本简介 卡特兰数（英文名：Catalan number）又称卡塔兰数，是组合数学中一个常出现在各种计数问题中的数列。 卡特兰数的首创者是中国清代数学家明安图。 通项公式，递推关系 (1)Hn=C2nn−C2nn−1(1) \\quad H_n = C_{2n}^{n} - C_{2n}^{n-1}(1)Hn​=C2nn​−C2nn−1​ (2)Hn=1n+1C2nn(2) \\quad H_n = \\frac{1}{n+1}C_{2n}^{n}(2)Hn​=n+11​C2nn​ (3)Hn=4n−2n+1Hn−1(3) \\quad H_n = \\frac{4n-2}{n+1}H_{n-1}(3)Hn​=n+14n−2​Hn−1​ 数列前n项 H0H_0H0​ H1H_1H1​ H2H_2H2​ H3H_3H3​ H4H_4H4​ H5H_5H5​ H6H_6H6​ H7H_7H7​ H8H_8H8​ H9H_9H9​ 1 1 2 5 14 42 132 429 1430 4862 H10H_{10}H10​ H11H_{11}H11​ H12H_{12}H12​ H13H_{13}H13​ H14H_{14}H14​ H15H_{15}H15​ H16H_{16}H16​ H17H_{17}H17​ H18H_{18}H18​ H19H_{19}H19​ 16796 58786 208012 742900 2674440 9694845 35357670 129644790 477638700 1767263190 应用 n个节点构造二叉树问题 出栈序列问题 括号匹配问题","categories":[],"tags":[]},{"title":"快速排序","slug":"快速排序","date":"2024-08-20T09:12:53.000Z","updated":"2024-08-20T09:31:42.381Z","comments":true,"path":"2024/08/20/快速排序/","link":"","permalink":"http://example.com/2024/08/20/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","excerpt":"","text":"快速排序 快速排序是一种分治算法，其基本思想是：通过一趟排序将待排序记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。 题目 洛谷P1177 版本1 部分测试点超时，本地跑第5个测试点，递归深度过深导致 segmentation fault 12345678910111213141516171819202122void quick_sort(int *a, int left, int right)&#123; if (left &gt;= right) return; int base = a[left]; int i = left, j = right; while (i &lt; j) &#123; while (i &lt; j &amp;&amp; a[j] &gt;= base) --j; a[j] = a[i]; while (i &lt; j &amp;&amp; a[i] &lt;= base) ++i; a[i] = a[j]; &#125; a[i] = base; quick_sort(a, left, i - 1); quick_sort(a, i + 1, right);&#125; 版本2 AC版本 123456789101112131415161718192021222324void quick_sort(int *a, int left, int right)&#123; if (left &gt;= right) return; int i = left - 1, j = right + 1; int x = a[left + right &gt;&gt; 1]; while (i &lt; j) &#123; do ++i; while (a[i] &lt; x); do --j; while (a[j] &gt; x); if (i &lt; j) swap(a[i], a[j]); &#125; quick_sort(a, left, j); quick_sort(a, j + 1, right);&#125; 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void quick_sort(int *a, int left, int right)&#123; if (left &gt;= right) return; int i = left - 1, j = right + 1; int x = a[left + right &gt;&gt; 1]; while (i &lt; j) &#123; do ++i; while (a[i] &lt; x); do --j; while (a[j] &gt; x); if (i &lt; j) swap(a[i], a[j]); &#125; quick_sort(a, left, j); quick_sort(a, j + 1, right);&#125;int main()&#123; int n; cin &gt;&gt; n; vector&lt;int&gt; a(n); for (int i = 0; i &lt; n; ++i) cin &gt;&gt; a[i]; quick_sort(&amp;a[0], 0, n - 1); for (int i = 0; i &lt; n; ++i) cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; return 0;&#125;","categories":[],"tags":[]},{"title":"hexo d时产生的bug","slug":"hexo-d时产生的bug","date":"2024-06-21T05:25:18.000Z","updated":"2024-06-21T05:58:19.053Z","comments":true,"path":"2024/06/21/hexo-d时产生的bug/","link":"","permalink":"http://example.com/2024/06/21/hexo-d%E6%97%B6%E4%BA%A7%E7%94%9F%E7%9A%84bug/","excerpt":"","text":"bug信息 123456789101112131415161718192021222324INFO Validating configINFO =================================================================== ##### # # ##### ##### ###### ##### ###### # # # # # # # # # # # # # # # # ##### # # # # ##### # # ##### # # # # # # # # # ##### # # # # # # # # # # # # # # # ##### #### # # ###### # # # ###### # 4.9.0 ===================================================================INFO Deploying: gitINFO Clearing .deploy_git folder...INFO Copying files from public folder...INFO Copying files from extend dirs...On branch masternothing to commit, working tree cleanfatal: unable to access &#x27;https://github.com/WangShiSuiFeng24/WangShiSuiFeng24.github.io.git/&#x27;: SSL certificate problem: unable tole to get local issuer certificateFATAL Something&#x27;s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.htmlError: Spawn failed at ChildProcess.&lt;anonymous&gt; (C:\\Users\\mingandong\\blog\\node_modules\\hexo-util\\lib\\spawn.js:51:21) at ChildProcess.emit (node:events:514:28) at cp.emit (C:\\Users\\mingandong\\blog\\node_modules\\cross-spawn\\lib\\enoent.js:34:29) at ChildProcess._handle.onexit (node:internal/child_process:291:12) 解决方法 这个问题是由于一些问题导致无法访问 GitHub。具体来说，错误信息显示 SSL 证书的问题，无法获取本地发行者证书。 解决此问题的一种可能方法是将 Git 配置更改为允许不验证 SSL 证书。可以使用以下命令来更改 Git 的全局配置： 1git config --global http.sslVerify false 然后再次尝试执行操作(hexo d)，看是否能够成功访问 GitHub 仓库。 这里已经能解决问题了，但是，如果还不行，可以尝试以下方法 可以尝试更新 Git 的证书存储。这可以通过以下步骤完成：下载最新的证书存储文件：https://curl.haxx.se/ca/cacert.pem。 将证书存储文件保存到你的电脑上的某个目录中，比如 C:\\。 打开 Git Bash 或命令提示符，并运行以下命令： 1git config --global http.sslCAInfo C:/cacert.pem 确保将路径 C:/cacert.pem 替换为实际保存证书存储文件的路径。这些方法应该能够解决问题。如果问题仍然存在，参考 Hexo 文档中的故障排除指南，可能会提供更多有关此错误的解决方案。","categories":[],"tags":[]},{"title":"谷歌翻译问题解决方案","slug":"谷歌翻译问题解决方案","date":"2024-06-21T04:22:59.000Z","updated":"2024-06-21T04:57:42.931Z","comments":true,"path":"2024/06/21/谷歌翻译问题解决方案/","link":"","permalink":"http://example.com/2024/06/21/%E8%B0%B7%E6%AD%8C%E7%BF%BB%E8%AF%91%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"","text":"装插件 浏览器扩展程序中装 Google翻译 插件 登录github，找工具 使用 steam++(已改名为Watt Toolkit) 加速访问 github https://steampp.net/ 搜索栏搜索 GoogleTranslate_IPFinder https://github.com/GoodCoder666/GoogleTranslate_IPFinder 点击稳定版下载地址， 若下载缓慢或无法下载，您可以通过 GitHub Proxy 代理加速下载 https://github.com/GoodCoder666/GoogleTranslate_IPFinder/releases 运行工具 工具名：checker-win-x64.exe。 右键-&gt;以管理员身份运行， 点击“测速”，等待操作完成， 点击“写入Hosts”，谷歌翻译API即可正常使用。 此时，网页中 右键-&gt;翻译成中文(简体) 可正常使用。 另外 管理身份打开hosts文件。 C:\\Windows\\System32\\drivers\\etc&gt;notepad hosts 在前面生成的相同ip下，添加translate.google.com 例(前两个由工具生成，最后一个手动添加)： 216.239.32.40 translate.googleapis.com 216.239.32.40 translate-pa.googleapis.com 216.239.32.40 translate.google.com 保存。 如此可实现 选中-&gt;右键-&gt;谷歌翻译。 还可直接访问谷歌翻译网页。 https://translate.google.com","categories":[],"tags":[]},{"title":"bilibili视频解析下载+字幕+压缩","slug":"bilibili视频解析下载-字幕-压缩","date":"2023-11-24T00:33:09.000Z","updated":"2023-11-24T00:55:39.706Z","comments":true,"path":"2023/11/24/bilibili视频解析下载-字幕-压缩/","link":"","permalink":"http://example.com/2023/11/24/bilibili%E8%A7%86%E9%A2%91%E8%A7%A3%E6%9E%90%E4%B8%8B%E8%BD%BD-%E5%AD%97%E5%B9%95-%E5%8E%8B%E7%BC%A9/","excerpt":"","text":"视频解析 https://bili.iiilab.com/ bcc字幕下载 字幕 -&gt; 添加字幕 -&gt; 中文（中国）-&gt; 编辑 -&gt; 下载 bcc字幕转srt字幕 https://www.dreamlyn.cn/bsrt srt字幕是剪映支持的字幕格式 剪映合成字幕和视频 官方下载剪映即可 手动拖入即可，最后导出 QQ影音压缩 官方QQ影音已被下架 QQ影音下载 http://dldir1.qq.com/qqyy/pc/QQPlayer_Setup_39_936.exe 导入视频 -&gt; 影音工具箱 -&gt; 压缩 -&gt; 参数设置 -&gt; 开始压缩 压缩到20M以内，可以发送到微信","categories":[],"tags":[]},{"title":"aplayer实现音乐播放","slug":"aplayer音乐","date":"2023-09-07T12:24:27.000Z","updated":"2023-09-15T02:23:26.483Z","comments":true,"path":"2023/09/07/aplayer音乐/","link":"","permalink":"http://example.com/2023/09/07/aplayer%E9%9F%B3%E4%B9%90/","excerpt":"","text":"var _param = { getCustomPlayList: function () { const musicPage = document.getElementById(\"music-page\"); musicPage.innerHTML = ``; } }; _param.getCustomPlayList();","categories":[],"tags":[]},{"title":"Docker+Wordpress 搭建个人博客","slug":"Docker-Wordpress-搭建个人博客","date":"2023-09-02T11:49:49.000Z","updated":"2023-09-02T12:29:22.760Z","comments":true,"path":"2023/09/02/Docker-Wordpress-搭建个人博客/","link":"","permalink":"http://example.com/2023/09/02/Docker-Wordpress-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"Windows10示例 安装docker 在docker 官网选择Download for Windows。 更新WSL 1wsl --update 修改docker镜像为国内镜像 打开 Docker Desktop -&gt; 设置 -&gt; Docker Engine 修改并添加： 12&quot;experimental&quot; true,&quot;registry-mirrors&quot;: [&quot;https://yxzrazem.mirror.aliyuncs.com&quot;] 新建个人博客文件夹 12mkdir my_wordpress_blogcd my_wordpress_blog 建立docker-compose.yml文件，并添加内容 12345678910111213141516171819202122232425262728version: &#x27;3.3&#x27;services: db: image: mysql:5.7 volumes: - db_data:/var/lib/mysql restart: always environment: MYSQL_ROOT_PASSWORD: somewordpress MYSQL_DATABASE: wordpress MYSQL_USER: wordpress MYSQL_PASSWORD: wordpress wordpress: depends_on: - db image: wordpress:latest ports: - &quot;8000:80&quot; restart: always environment: WORDPRESS_DB_HOST: db:3306 WORDPRESS_DB_USER: wordpress WORDPRESS_DB_PASSWORD: wordpress WORDPRESS_DB_NAME: wordpressvolumes: db_data: &#123;&#125; 部署完成 1docker compose up -d 本地 localhost:8000 访问博客","categories":[],"tags":[]},{"title":"生疏单词收集","slug":"生疏单词收集","date":"2023-08-29T01:48:19.000Z","updated":"2023-09-15T02:36:53.099Z","comments":true,"path":"2023/08/29/生疏单词收集/","link":"","permalink":"http://example.com/2023/08/29/%E7%94%9F%E7%96%8F%E5%8D%95%E8%AF%8D%E6%94%B6%E9%9B%86/","excerpt":"","text":"英语单词收集 otherwise 否则 tutorial 教程 installation wizard 安装向导 ecosystem 生态系统 duplicate 重复的，复制的 efforts 努力 take on new responsibilities 承担新的责任 presence 存在，出现 constitute 组成，构成 endorsement (公开的)赞同，认可，支持，背书 entirely 完全地，全部地 even then 即使那样，即使这样 figure out 弄清楚 step through 单步执行 overview 概述 approximation 近似，近似值 peek definition 查看定义 potential 潜在的 scenarios 场景 semicolon 分号 preprocessor 预处理器 directive 指令 terminator 终止符 argument list 形参列表 parameter list 参数列表 original style 原创风格 very explicit style 非常明确的风格 manipulator 控制符 invalid 无效的，(法律上或官方)不承认的 carriage return 回车，换行 omitted 删除的，省略的 extensible 可扩展的 function prototype 函数原型 function 函数 procedure 过程 subroutine 子程序 toes 脚趾 absent from 缺席 stone 英石 (1 stone = 14 pounds) pound 磅 repositioning 重新定位 Celsius 摄氏的，摄氏 Fahrenheit 华氏的 astronomical 天文的 astronomical unit 天文单位 reserved 保留的 underscore 下划线(_) digit 数字 even more distinct 甚至更加明显 hyphen 连字符(-) yield 产生 developing 开发 shipping 发布 running 运行 infrastructure 基础设施 separate A from B 把A和B分开 deliver software 交付软件 in the same ways 用同样的方式 methodologies 方法论 significantly 显著地 delay 延迟 loosely 松散地 isolated 隔离的 container 容器 isolation 隔离 simultaneously 同时地 a hybrid of the two 两者地混合体 streamline the development lifecycle 简化开发生命周期 laptop 笔记本电脑 portability 可移植性 scaling up 扩展 tearing down 拆除 viable 可行的 cost-effective 经济高效的，性价比高的 density 密度 registry 注册表 template 模板 prior 事先的 exceed 超过 literal 字面意义的，字面量 definitely 明确地 mantissa 尾数 copyright 版权 Inc (incorporated 注册成立) 股份有限公司 foundation 基金会 warranty 担保 implied 不言而喻的，暗示的 merchantability 适销性 fitness 适合 granted （被）允许，准许，同意 arithmetic 算术 associativity 结合性 ditto 同上 foot 英尺 （1 foot = 12 inches) inch 英寸 illegal 非法的 mismatch 错配 feline 猫 penguin 企鹅 anonymous 匿名的 enumeration 枚举 enumerated type 枚举类型 enumerator 枚举量，枚举符 pointer arithmetic 指针算术 factorial 阶乘 prefix 前缀 postfix 后缀 comma 逗号 semicolon 分号 entry-condition 入口条件 exit-condition 出口条件 sentinel 哨兵 punctuation 标点符号 terminate 终止 sales 销售量 expenses 费用，开支 employee 雇员，雇工 in the industry 在行业中 the board of directors 董事会 lips 嘴唇 nails 指甲 sweatsuit 运动套服 mood 情绪，心情 period 句点，句号 numeric 数字的 non-numeric 非数字的 automobile 汽车 make and model 品牌和型号 odds 几率 cookies 曲奇饼 properties 财产，房地产，不动产 bottom-up programming 自下而上的程序设计 top-down programming 从上而下的程序设计 angle 角度 astronomical sights 天文景点 spring 春天 summer 夏天 fall 秋天 winter 冬天 season 季节 aliase 别名 wallet 钱包 rats 老鼠，耗子 rodents 啮齿动物，啮齿类 bunnies 兔子(bunny) cube 立方体 立方 evaluate 评价，评估 nonsensical 荒谬的 sensical 感官的 alter 改变 telescope 望远镜 focal length 焦距 eyepiece 目镜 function signature 函数特征标（函数参数列表） specialization 专业化，专门化，特化 instantiation 实例化，实例 template instantiation 模板实例 implicit instantiation 隐式实例化 overrides 优先于，压倒，推翻 general 一般的，总的，普遍的 explicit instantiation 显示实例化 explicit specialization 显示特化，显示具体化","categories":[],"tags":[]},{"title":"官网技术文档收集","slug":"官网技术文档收集","date":"2023-08-28T02:15:28.000Z","updated":"2024-09-05T02:45:12.810Z","comments":true,"path":"2023/08/28/官网技术文档收集/","link":"","permalink":"http://example.com/2023/08/28/%E5%AE%98%E7%BD%91%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%E6%94%B6%E9%9B%86/","excerpt":"","text":"官方网站+技术文档 LATEX LATEX 官网 LATEX 官方文档(英文) LATEX 官方文档(中文翻译) 在线LaTeX公式编辑器 HEXO HEXO 官网 HEXO 官方文档 Visual Studio Code VS code 官网 VS code 官方文档 Git Git 官网 Git 官方文档 CommonMarkdown CommonMark 官网 CommonMark 基本操作 VS code Markdown Markdown and Visual Studio Code hexo-theme-butterfly hexo-theme-butterfly Github hexo-theme-butterfly 官方文档 GitHub Flavored Markdown 的正式规范 GitHub Flavored Markdown 的正式规范 GitHub 风格的 Markdown 规范 docker docker 官网 docker 官方文档 待续","categories":[],"tags":[]},{"title":"Markdown常用语法","slug":"Markdown常用语法","date":"2023-08-06T12:58:46.000Z","updated":"2024-09-05T12:39:21.371Z","comments":true,"path":"2023/08/06/Markdown常用语法/","link":"","permalink":"http://example.com/2023/08/06/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/","excerpt":"","text":"一、Markdown简介 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。 Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。 Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。 Markdown 编写的文档后缀为 .md, .markdown。 Markdown 能被使用来撰写电子书，如：Gitbook。 当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge等。 Markdown编写Hello World!语法： 1# Hello World! 二、Markdown标题 使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。 使用#号标记标题语法格式： 1234567891011# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 显示效果： 一级标题 二级标题 三级标题 四级标题 五级标题 六级标题 三、Markdown段落 Markdown 的段落没有特殊的格式，直接编写文字就好，段落的换行号是使用两个以上的空格加回车。 3.1 字体 Markdown 可以使用以下几种字体： 用1个星号*或底线_表示斜体 用2个星号*或底线_表示粗体 用3个星号*或底线_表示粗斜体 语法格式： 1234567891011*斜体文字*_斜体文字_**粗体文字**__粗体文字__***粗斜体文字***___粗斜体文字___ 显示效果 斜体文字 斜体文字 粗体文字 粗体文字 粗斜体文字 粗斜体文字 3.2 分割线 可以在一行中用三个以上的星号*、减号-、底线_来建立一个分割线，行内不能有其他东西，你也可以在星号或减号蹭插入空格。下面这种写法都可以建立分隔线： 12345**** * *******- - ------- 显示效果： 3.3 删除线 如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线~~即可。 123baidu.comsina.com~~tencent.com~~ 显示效果如下： baidu.com sina.com tencent.com 3.4 下划线 下划线可以通过HTML的标签来实现 1&lt;u&gt;带下划线文本&lt;/u&gt; 显示效果如下： 带下划线文本 3.5 脚注 脚注是对文本的补充说明。 1[^要注明的文本]： 显示效果： [^要注明的文本]:input description here 四、Markdown 列表 4.1 有序列表和无序列表 Markdown支持有序列表和无序列表，无序列表使用星号(*)、加号(+)或者减号(-)作为标记： 1234567891011* 第一项* 第二项* 第三项+ 第一项+ 第二项+ 第三项- 第一项- 第二项- 第三项 显示效果： 第一项 第二项 第三项 第一项 第二项 第三项 第一项 第二项 第三项 有序列表直接在文字有加上1. 2. 3. 来表示，符号和文字之间加上一个空格字符，如： 1231. 第一项2. 第二项3. 第三项 第一项 第二项 第三项 4.2 列表嵌套 列表嵌套只需在子列表的选项前添加四个空格即可： 1234561. 第一项： - 第一项嵌套的第一个元素 - 第一项嵌套的第二个元素2. 第二项： - 第二项嵌套的第一个元素 - 第二项嵌套的第二个元素 显示效果： 第一项 第一项嵌套的第一个元素 第一项嵌套的第二个元素 第二项 第二项嵌套的第一个元素 第二项嵌套的第二个元素 五、Markdown区块 Markdown区块引用是在段落开头使用&gt;符号，然后后面紧跟一个空格符号。 123&gt; 区块引用&gt; Markdown教程&gt; 学的不仅是技术更是梦想 显示效果如下： 区块引用 Markdown教程 学的不仅是技术更是梦想 另外区块是可以嵌套的，一个&gt;符号是最外层，两个符号是第一层嵌套，以此类推： 123&gt; 最外层&gt;&gt; 第一层嵌套&gt;&gt;&gt; 第二层嵌套 显示效果如下： 最外层 第一层嵌套 第二层嵌套 5.1 区块中使用列表 区块中使用列表实例如下： 123456&gt; 区块中使用列表&gt; 1. 第一项&gt; 2. 第二项&gt; + 第一项&gt; + 第二项&gt; + 第三项 显示效果： 区块中使用列表 1. 第一项 2. 第二项 + 第一项 + 第二项 + 第三项 5.2 列表中使用区块 如果要在列表项目内放进区块，那么就需要在&gt;前添加四个空格和缩进。 1234- 第一项 &gt; Markdown教程 &gt; 学的不仅是技术更是梦想- 第二项 显示效果如下： 第一项 Markdown教程 学的不仅是技术更是梦想 第二项 六、Markdown代码框 如果是段落上的一个函数或片段的代码可以用两个`把它包起来。 1`print()`函数 print()函数 6.1 代码区块 代码区块使用4个空格或者一个制表符（Tab键）。 1234&lt;?Python print(&#x27;Markdown&#x27;) def test(): print(&#x27;Markdown test!&#x27;) 也可以用```包裹一段代码，并指定一种语言（也可以不指定）： 12345`` ``` ``(javascript)$(document).read(function()&#123; alert(&#x27;Markdown&#x27;);&#125;);`` ``` `` 显示效果： 123$(document).read(function()&#123; alert(&#x27;Markdown&#x27;);&#125;); 七、Markdown链接 链接方法使用如下 123[链接名称](链接地址)或者&lt;链接地址&gt; 例如： 12这是一个链接 [新浪新闻](https://news.sina.com.cn/)&lt;https://news.sina.com.cn/&gt; 显示效果如下： 这是一个链接 新浪新闻 https://news.sina.com.cn/ 7.1 高级链接 1234链接也可以用变量来代替，文档末尾附带变量地址：这个链接用1作为网址变量[baidu][1]这个链接用markdown作为网址变量[Markdown][markdown]然后文档的结尾为变量赋值(网址) 12[1]: http://www.baidu.com[markdown]: http://www.markdown.com 显示效果如下： 链接也可以用变量来代替，文档末尾附带变量地址： 这个链接用1作为网址变量baidu 这个链接用markdown作为网址变量Markdown 然后文档的结尾为变量赋值(网址) 八、Markdown图片 Markdown图片语法格式为： 12![alt 属性文本](图片地址)![alt 属性文本](图片地址 &quot;可选标题&quot;) 开头一个感叹号！ 接着一个方括号，里面放上图片的代替文字 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的‘title’属性文字。 示例如下： 1234![有问题上知乎 图标](https://cdn.staticaly.com/gh/WangShiSuiFeng24/picx-images-hosting@master/20230807/image.1oqer6reup34.webp)--- 显示效果如下： 也可以像网址那样对图片使用变量： 123这个图片链接用1作为网址变量[zhihu][1]然后在文档的结尾为变量赋值(网址)[1]:(https://cdn.staticaly.com/gh/WangShiSuiFeng24/picx-images-hosting@master/20230807/image.1oqer6reup34.webp) 显示效果如下： 这个图片用1作为网址变量zhihu 然后在文档的结尾为变量赋值(网址) Markdown 没有办法指定图片的高度与宽度，如果需要的话，可以使用普通的标签。 1&lt;img src=&quot;https://cdn.staticaly.com/gh/WangShiSuiFeng24/picx-images-hosting@master/20230807/image.1oqer6reup34.webp&quot; width=10%&gt; 显示效果： 九、Markdown表格 Markdown制作表格使用|来分隔不同的单元格，使用-来分隔表头和其他行。 语法格式： 1234|表头1|表头2||----|----||单元格11|单元格12||单元格21|单元格22| 表头1 表头2 单元格11 单元格12 单元格21 单元格22 9.1 对齐方式 可以设置表头的对齐方式： -: 设置内容或标题栏右对齐 :- 设置内容或标题栏左对齐 :-: 设置内容或标题栏居中对齐 语法格式： 1234|左对齐|居中对齐|右对齐||:----|:----:|----:||单元格11|单元格12|单元格13||单元格21|单元格22|单元格23| 左对齐 居中对齐 右对齐 单元格11 单元格12 单元格13 单元格21 单元格22 单元格23 十、Markdown高级技巧 支持的HTML元素 不在Markdown涵盖范围之类的标签，都可以直接在文档里面用HTML撰写。 如： 1使用&lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt;重启电脑 显示效果如下： 使用Ctrl+Alt+Del重启电脑 10.1 转义 Markdown使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown使用反斜杠转义特殊字符： 12**文本加粗**\\*\\*正常显示星号\\*\\* 显示效果： 文本加粗 **正常显示星号** Markdown支持一下这些符号前面加上反斜杠来帮助插入普通符号： 1234567891011\\ 反斜线` 反引号* 星号_ 下划线&#123;&#125; 花括号[] 方括号() 小括号+ 加号- 减号. 英文句点! 感叹号 10.2 数学公式 当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。 示例如下： 123$$\\int_0^1 &#123;x^2&#125; \\,&#123;\\rm d&#125;x$$ 显示效果： ∫01x2 dx\\int_0^1 {x^2} \\,{\\rm d}x ∫01​x2dx 参考链接 CommonMark VS code Markdown 在线Markdown编辑器 在线LaTeX公式编辑器","categories":[],"tags":[]},{"title":"待买书籍","slug":"待买书籍","date":"2023-08-04T14:25:50.000Z","updated":"2023-08-04T14:55:39.489Z","comments":true,"path":"2023/08/04/待买书籍/","link":"","permalink":"http://example.com/2023/08/04/%E5%BE%85%E4%B9%B0%E4%B9%A6%E7%B1%8D/","excerpt":"","text":"Python: ​ Python从入门到实践 ​ Python核心编程 Java核心技术(两卷,这个简单一点) 算法: ​ 算法 计算机网络: ​ TCP/IP协议栈 Linux: ​ Unix环境高级编程(企业级别C) JavaEE框架: ​ Spring 实战 ​ SpringBoot实战 ​ Spring技术内幕 数据库: ​ MySQL必知必会 ​ 提升: ​ 高性能MySQL 代码质量: ​ 重构改善既有代码的设计","categories":[],"tags":[]},{"title":"centos7 使用hexo框架搭建博客成功","slug":"centos7-使用hexo框架搭建博客成功","date":"2023-08-04T12:44:11.741Z","updated":"2023-08-26T06:44:38.528Z","comments":true,"path":"2023/08/04/centos7-使用hexo框架搭建博客成功/","link":"","permalink":"http://example.com/2023/08/04/centos7-%E4%BD%BF%E7%94%A8hexo%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%88%90%E5%8A%9F/","excerpt":"","text":"1、安装git yum install git -y 2、使用wget下载nodejs 16.15.0版本的压缩包 wget https://nodejs.org/dist/v16.15.0/node-v16.15.0-linux-x64.tar.gz 3、解压缩node-v16.15.0到当前文件夹 tar -zxvf node-v16.15.0-linux-x64.tar.gz 4、移动解压后的node-v16.15.0到/urs/local/bin 目录下，并改名为node mv node-v16.15.0-linux-x64 /usr/local/bin cd /usr/local/bin mv node-v16.15.0-linux-x64 node 5、更改环境变量 vim /etc/profile 末尾添加： export NODE_HOME=/usr/local/bin/node export PATH=$PATH:$NODE_HOME/bin 6、更新环境变量 source /etc/profile 7、检查node、npm是否安装配置成功 node -v npm -v 8、使用npm安装cnpm npm install -g cnpm --registry=https://registry.npm.taobao.org cnpm -v 9、使用cnpm安装hexo cnpm install -g hexo-cli hexo -v 10、开始使用hexo框架，初始化博客目录 cd ~ mkdir blog cd blog hexo init 11、需要防火墙打开4000端口 firewall-cmd --zone=public --add-port=4000/tcp --permanent firewall-cmd --reload 12、启动hexo服务，恭喜你成功搭建成功 hexo s 参考链接 hexo 官方文档","categories":[],"tags":[]},{"title":"我的第一篇博客文章","slug":"我的第一篇博客文章","date":"2023-08-01T12:46:10.000Z","updated":"2023-08-03T10:26:27.274Z","comments":true,"path":"2023/08/01/我的第一篇博客文章/","link":"","permalink":"http://example.com/2023/08/01/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/","excerpt":"","text":"第一章 内容修改 第二章 内容 参考文献 www.codesheep.com","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2023-08-01T12:38:57.802Z","updated":"2023-08-01T12:38:57.803Z","comments":true,"path":"2023/08/01/hello-world/","link":"","permalink":"http://example.com/2023/08/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}