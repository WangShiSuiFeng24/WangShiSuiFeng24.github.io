{"meta":{"title":"往事丶随风的博客","subtitle":"我是子标题","description":"华中师范大学 计算机应用技术专业","author":"AndongMing","url":"http://example.com","root":"/"},"pages":[{"title":"分类","date":"2023-08-27T01:12:22.000Z","updated":"2023-08-27T01:13:15.183Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-08-27T01:15:40.000Z","updated":"2023-08-27T01:16:18.054Z","comments":true,"path":"link/index.html","permalink":"http://example.com/link/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-08-27T01:09:37.000Z","updated":"2023-08-27T01:11:01.492Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"主要元素","slug":"主要元素","date":"2024-10-17T04:36:41.000Z","updated":"2024-10-18T01:25:02.634Z","comments":true,"path":"2024/10/17/主要元素/","link":"","permalink":"http://example.com/2024/10/17/%E4%B8%BB%E8%A6%81%E5%85%83%E7%B4%A0/","excerpt":"","text":"问题 求主要元素 主要元素（Majority Element）问题是经典的算法问题之一，其定义如下：给定一个数组 nums，找出数组中的主要元素，即出现次数超过数组长度一半的元素。 P2397 yyy loves Maths VI (mode) 哈希表法 哈希表法通过记录每个元素出现的次数来找到主要元素。 时间复杂度：O(n)O(n)O(n) 空间复杂度：O(n)O(n)O(n)。 1234567891011121314151617#include &lt;vector&gt;#include &lt;unordered_map&gt;using namespace std;int majorityElement(vector&lt;int&gt;&amp; nums) &#123; unordered_map&lt;int, int&gt; counts; for (int num : nums) &#123; ++counts[num]; if (counts[num] &gt; nums.size() / 2) &#123; return num; &#125; &#125; // 如果没有主要元素，可以根据题目要求返回特定值，例如 -1 // 理论上不会到达这里，因为题目保证存在主要元素 return -1; &#125; 摩尔投票法 摩尔投票算法（Boyer-Moore Voting Algorithm）。 时间复杂度为：O(n)O(n)O(n) 空间复杂度为：O(1)O(1)O(1) 摩尔投票算法 初始化：计数count初始化为 0。 遍历数组： 如果计数count为 0，则选择当前元素作为新的候选元素candidate = nums[i]，并将计数count置为 1。 对于当前元素，如果它与候选元素相同，则增加计数count。 否则，减少计数count。 验证候选元素：最后，再次遍历数组，统计候选元素candidate出现的次数occurrence是否超过数组长度的一半。 C++ 代码示例 以下是使用摩尔投票算法实现的主要元素问题的 C++ 代码： 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;vector&gt;// 摩尔投票算法int majorityElement(const std::vector&lt;int&gt;&amp; nums) &#123; int candidate; int count = 0; for (size_t i = 0; i &lt; nums.size(); ++i) &#123; if (count == 0) &#123; candidate = nums[i]; count = 1; &#125; else if (nums[i] == candidate) count++; else count--; &#125; // 验证候选元素 int occurrence = 0; for (int num : nums) if (num == candidate) occurrence++; if (occurrence &gt; nums.size() / 2) return candidate; else // 如果没有主要元素，可以根据题目要求返回特定值，例如 -1 // 理论上不会到达这里，因为题目保证存在主要元素 return -1;&#125; 这种方法简单高效，适用于大多数主要元素问题的场景。 摩尔投票算法的联机特性 联机算法（Online Algorithm） 联机算法是指可以在数据流中逐个处理数据的算法，而不是一次性接收所有数据。这类算法的特点是： 逐个处理：每次只处理一个数据项。 优先存储：算法使用的存储空间通常是固定的，不随输入数据的大小而变化。 即时决策：在处理每个数据项时，算法必须做出即时决策，不能回溯或重新处理之前的数据。 求最大子序和的Kadane算法就是一种满足以上条件的联机算法。 投票算法投票步骤 逐个处理： 摩尔投票算法在遍历数组时，每次只处理一个元素，符合联机算法的逐个处理特性。 有限存储： 算法只需要维护一个候选元素和一个计数器，存储空间是固定的，不随输入数据的大小而变化。 即时决策： 在处理每个元素时，算法根据当前的候选元素和计数器做出即时决策，决定是否更新候选元素或计数器。 投票算法验证步骤 虽然摩尔投票的核心部分是联机的，但验证候选元素是否为主要元素的步骤需要再次遍历数组。这一部分是离线的，因为它需要访问整个数组来统计候选元素的出现次数。 结论 联机部分：摩尔投票算法的核心部分（选择候选元素和维护计数器）是联机的，可以在数据流中逐个处理数据。 离线部分：验证候选元素是否为主要元素的部分是离线的，需要再次遍历数组。 因此，摩尔投票算法可以被视为一种部分联机算法，因为它在处理数据时具有联机算法的特性，但在验证结果时需要离线处理。","categories":[],"tags":[]},{"title":"最大子序列和","slug":"最大子序列和","date":"2024-10-16T09:27:38.000Z","updated":"2024-10-17T04:31:18.611Z","comments":true,"path":"2024/10/16/最大子序列和/","link":"","permalink":"http://example.com/2024/10/16/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C/","excerpt":"","text":"题目描述 最大子序列和，也称最大子数组和、最大子段和等。 给出一个长度为 nnn 的序列 numsnumsnums，选出其中连续且非空的一段使得这段和最大。 P1115 最大子段和 解法一 时间复杂度：O(n3)O(n^3)O(n3) 空间复杂度：O(1)O(1)O(1) 123456789101112131415161718192021int max_sub_sequence_sum(const vector&lt;int&gt;&amp; nums)&#123; int max_sum = INT_MIN; int sum = 0; int n = nums.size(); for (int i = 0; i &lt; n; ++i) &#123; sum = 0; for (int j = i; j &lt; n; ++j) &#123; for (int k = i; k &lt;= j; ++k) sum += nums[k]; if (sum &gt; max_sum) max_sum = sum; &#125; &#125; return max_sum;&#125; 解法二 时间复杂度：O(n2)O(n^2)O(n2) 空间复杂度：O(1)O(1)O(1) 12345678910111213141516171819int max_sub_sequence_sum(const vector&lt;int&gt;&amp; nums)&#123; int max_sum = INT_MIN; int sum = 0; int n = nums.size(); for (int i = 0; i &lt; n; ++i) &#123; sum = 0; for (int j = i; j &lt; n; ++j) &#123; sum += nums[j]; if (sum &gt; max_sum) max_sum = sum; &#125; &#125; return max_sum;&#125; 解法三 前缀和法 时间复度：O(n2)O(n^2)O(n2) 空间复杂度：O(n)O(n)O(n) 1234567891011121314151617int max_sub_sequence_sum(const vector&lt;int&gt;&amp; nums)&#123; int n = nums.size(); // 初始化前缀和数组 vector&lt;int&gt; prefix_sum(n + 1); prefix_sum[0] = 0; for (int i = 0; i &lt; n; ++i) prefix_sum[i + 1] = prefix_sum[i] + nums[i]; int max_sum = INT_MIN; for (int i = 1; i &lt;= n; ++i) for (int j = i; j &lt;= n; ++j) max_sum = max(max_sum, prefix_sum[j] - prefix_sum[i - 1]); return max_sum;&#125; 优化前缀和法 前缀和法求最大子序列和的核心思想是利用前缀和数组来快速计算任意子数组的和，并通过维护一个最小前缀和来找到最大子序列和。 前缀和数组的定义： 前缀和数组 prefixSum 的每个元素 prefixSum[i] 表示从数组的第一个元素到第 i-1 个元素的累加和。即： prefixSum[i]=∑j=0i−1nums[j]\\text{prefixSum}\\lbrack i \\rbrack = \\sum\\limits_{j=0}^{i-1} \\text{nums}\\lbrack j \\rbrackprefixSum[i]=j=0∑i−1​nums[j] 子数组和的计算 对于任意子数组 nums[l]到 nums[r]，其和可以表示为： ∑j=lrnums[j]=prefixSum[r+1]−prefixSum[l]\\sum\\limits_{j=l}^{r} \\text{nums}\\lbrack j \\rbrack = \\text{prefixSum}\\lbrack r+1 \\rbrack - \\text{prefixSum}\\lbrack l \\rbrackj=l∑r​nums[j]=prefixSum[r+1]−prefixSum[l] 最大子序列和的计算 为了找到最大子序列和，我们需要找到一个子数组 nums[l] 到 nums[r]，使得其和最大。即：max⁡l≤r(prefixSum[r+1]−prefixSum[l])\\max\\limits_{l \\leq r} \\left( \\text{prefixSum}\\lbrack r+1 \\rbrack - \\text{prefixSum}\\lbrack l \\rbrack \\right)l≤rmax​(prefixSum[r+1]−prefixSum[l]) 维护最小前缀和 在遍历前缀和数组的过程中，我们维护一个最小前缀和 minPrefixSum，这样可以在每一步计算当前前缀和与最小前缀和的差值，这个差值就是以当前元素结尾的最大子序列和。 具体步骤如下： 初始化 minPrefixSum 为 0，maxSum 为负无穷大。 遍历前缀和数组 prefixSum： 对于每个 i，计算 prefixSum[i] - minPrefixSum，更新 maxSum。 更新 minPrefixSum 为 min(minPrefixSum, prefixSum[i])。 示例 假设输入数组 nums 为 [-2, 1, -3, 4, -1, 2, 1, -5, 4]，前缀和数组 prefixSum 为 [0, -2, -1, -4, 0, -1, 1, 2, -3, 1]。 iii nums[i]\\text{nums}\\lbrack i \\rbracknums[i] prefixSum[i]\\text{prefixSum}\\lbrack i \\rbrackprefixSum[i] minPrefixSum\\text{minPrefixSum}minPrefixSum maxSum\\text{maxSum}maxSum 000 −2-2−2 000 000 −2147483648-2147483648−2147483648 111 111 −2-2−2 −2-2−2 −2-2−2 222 −3-3−3 −1-1−1 −2-2−2 111 333 444 −4-4−4 −4-4−4 111 444 −1-1−1 000 −4-4−4 444 555 222 −1-1−1 −4-4−4 444 666 111 111 −4-4−4 555 777 −5-5−5 222 −4-4−4 666 888 444 −3-3−3 −4-4−4 666 999 越界越界越界 111 −4-4−4 666 最终，最大子序列和为 6，对应子数组 [4, -1, 2, 1]。 时间复杂度：O(n)O(n)O(n) 空间复杂度：O(n)O(n)O(n) 123456789101112131415161718192021// 计算最大子序列和int max_sub_sequence_sum(const vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;int&gt; prefixSum(n + 1, 0); // 前缀和数组 // 计算前缀和 for (int i = 1; i &lt;= n; i++) &#123; prefixSum[i] = prefixSum[i - 1] + nums[i - 1]; &#125; int minPrefixSum = 0; int maxSum = INT_MIN; // 遍历前缀和数组 for (int i = 1; i &lt;= n; ++i) &#123; maxSum = max(maxSum, prefixSum[i] - minPrefixSum); minPrefixSum = min(minPrefixSum, prefixSum[i]); &#125; return maxSum;&#125; 解法四 分治法 分治法也可以用来解决最大子序列和问题。分治法的核心思想是将问题分解成比较小的子问题，然后递归地解决这些子问题，并将结果合并起来得到最终答案。 具体来说，最大子序列问题可以分为以下几种情况： 最大子序列完全位于左半部分。 最大子序列完全位于右半部分。 最大子序列跨越中间位置。 分治法步骤 基本情况：如果数组中只有一个元素，直接返回该元素。 递归分解：将数组分成左右两部分，递归地求解左右两部分的最大子序列和。 跨越中间位置的最大子序列和：求解跨越中间位置的最大子序列和。 合并结果：取上述三种情况中的最大值作为最终答案。 时间复杂度：O(nlog⁡n)O(n \\log n)O(nlogn) 空间复杂度：O(log⁡n)O(\\log n)O(logn) 123456789101112131415161718192021222324252627282930313233int max_sub_sequence_sum(const vector&lt;int&gt;&amp; nums, int Left, int Right)&#123; if (Left == Right) return nums[Left]; int mid = (Left + Right) / 2; int max_left_sum = max_sub_sequence_sum(nums, Left, mid); int max_right_sum = max_sub_sequence_sum(nums, mid + 1, Right); int max_left_border_sum = INT_MIN; int left_border_sum = 0; for (int i = mid; i &gt;= Left; --i) &#123; left_border_sum += nums[i]; if (left_border_sum &gt; max_left_border_sum) max_left_border_sum = left_border_sum; &#125; int max_right_border_sum = INT_MIN; int right_border_sum = 0; for (int i = mid + 1; i&lt;= Right; ++i) &#123; right_border_sum += nums[i]; if (right_border_sum &gt; max_right_border_sum) max_right_border_sum = right_border_sum; &#125; return max(max(max_left_sum, max_right_sum), max_left_border_sum + max_right_border_sum);&#125; 解法五 KadaneKadaneKadane 算法 Kadane 算法是一种用于寻找最大子序列和的高效算法。它的核心思想是在遍历数组的过程中动态地维护当前子序列的最大和。（动态规划的思想） 算法步骤 初始化： max_sum：记录到目前为止的最大子序列和，初始值设为最小整数（INT_MIN）。 sum：记录以当前元素结尾的最大子序列和，初始值设为0。 遍历序列： 对于序列中的每个元素，更新sum，使其为当前元素加上之前的sum。 更新max_sum，使其为max(sum, max_sum)。 如果sum小于0，则将sum重置为0，因为负数会减少后续子序列的和。 返回结果： 遍历结束后，max_sum 即为最大子序列和。 时间复杂度：O(n)O(n)O(n) 空间复杂度：O(1)O(1)O(1) 1234567891011121314151617int max_sub_sequence_sum(const vector&lt;int&gt;&amp; nums)&#123; int max_sum = INT_MIN; int sum = 0; for (const auto &amp;x : nums) &#123; sum += x; if (sum &gt; max_sum) max_sum = sum; else if (sum &lt; 0) sum = 0; &#125; return max_sum;&#125; 解法六 动态规划 初始化：设 dp[i] 表示以 nums[i] 结尾的最大子序列和。 状态转移方程：dp[i] = max(dp[i - 1] + nums[i], nums[i])。 遍历过程中，max_sum = max(max_sum, dp[i])。max_sum记录最大子序列和。 优化： 因为只对数据进行一次扫描，一旦完成对nums[i]的读入和处理，就不再需要记忆它了。因此可省略nums数组，每次读入的元素用一个变量num表示。 dp[i] 只与 dp[i - 1] 和 num 有关，因此可以省略dp数组，只保存当前位置的最大子序列和，记为变量dp。 状态转移方程变为dp = max(dp + num, num)。 遍历过程中，max_sum = max(max_sum, dp)。 时间复杂度：O(n)O(n)O(n) 空间复杂度：O(1)O(1)O(1) 12345678910111213141516171819202122232425// 纯动态规划法#include &lt;iostream&gt;#include &lt;climits&gt;using namespace std;int main()&#123; int n; cin &gt;&gt; n; int num; // max_sum 记录最大和 int max_sum = INT_MIN; // dp 记录以 nums[i] 结尾的最大和 int dp = 0; for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; num; dp = max(dp + num, num); max_sum = max(max_sum, dp); &#125; cout &lt;&lt; max_sum; return 0;&#125;","categories":[],"tags":[]},{"title":"由程序直接生成 程序片段 的时间复杂度","slug":"由程序直接生成-程序片段-的时间复杂度","date":"2024-10-15T04:09:52.000Z","updated":"2024-10-15T04:53:29.820Z","comments":true,"path":"2024/10/15/由程序直接生成-程序片段-的时间复杂度/","link":"","permalink":"http://example.com/2024/10/15/%E7%94%B1%E7%A8%8B%E5%BA%8F%E7%9B%B4%E6%8E%A5%E7%94%9F%E6%88%90-%E7%A8%8B%E5%BA%8F%E7%89%87%E6%AE%B5-%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/","excerpt":"","text":"原理 我们知道，当nnn扩大一倍时，O(n)O(n)O(n)程序运行时间约乘以因子222，O(n2)O(n^2)O(n2)程序运行时间约乘以因子444，O(n3)O(n^3)O(n3)程序运行时间约乘以因子888，O(n4)O(n^4)O(n4)程序运行时间约乘以因子161616，O(n5)O(n^5)O(n5)程序运行时间约乘以因子323232。 程序代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142// 程序直接分析出 程序片段 的时间复杂度// 暂时只支持O(n), O(n^2), O(n^3), O(n^4), O(n^5), O(n^6)// 可以添加新的函数，但需要修改base数组和m数组#include &lt;iostream&gt;#include &lt;ctime&gt;#include &lt;string&gt;using namespace std;// O(n)void f1(int N)&#123; int sum = 0; for (int i = 0; i &lt; N; ++i) ++sum;&#125;// O(n^2)void f2(int N)&#123; int sum = 0; for (int i = 0; i &lt; N; ++i) for (int j = 0; j &lt; N; ++j) ++sum;&#125;// O(n^3)void f3(int N)&#123; int sum = 0; for (int i = 0; i &lt; N; ++i) for (int j = 0; j &lt; N * N; ++j) ++sum;&#125;// O(n^2)void f4(int N)&#123; int sum = 0; for (int i = 0; i &lt; N; ++i) for (int j = 0; j &lt; i; ++j) ++sum;&#125;// O(n^5)void f5(int N)&#123; int sum = 0; for (int i = 0; i &lt; N; ++i) for (int j = 0; j &lt; i * i; ++j) for (int k = 0; k &lt; j; ++k) ++sum;&#125;// O(n^4)void f6(int N)&#123; int sum = 0; for (int i = 0; i &lt; N; ++i) for (int j = 0; j &lt; i * i; ++j) if (j % i == 0) for (int k = 0; k &lt; j; ++k) ++sum;&#125;const int base_cnt = 6;int base[base_cnt] = &#123;2, 4, 8, 16, 32, 64&#125;;string m[base_cnt] = &#123;&quot;O(n)&quot;, &quot;O(n^2)&quot;, &quot;O(n^3)&quot;, &quot;O(n^4)&quot;, &quot;O(n^5)&quot;, &quot;O(n^6)&quot;&#125;;void solve(void (*f)(int), const string func_name)&#123; // sum 存储所有 当前时间/上一次时间 的和 double sum = 0; // sum 中存储值的个数 int cnt = 0; // 上一次时间 clock_t pre = 0; for (int n = 2; n &lt;= 100000000; n *= 2) &#123; clock_t s = clock(); f(n); clock_t e = clock(); // f当前运行时间 = 结束时间戳 - 开始时间戳 auto t = e - s; // 只有当上一次运行时间不为0，才计算 if (pre != 0) &#123; ++cnt; sum += (double)(t) / (double)pre; &#125; // 记录上一次运行时间 pre = t; // 经验值，使得程序能够在1分钟左右运行结束 if (pre &gt;= 5000) break; &#125; // 比率 的 平均值 double avg; if (cnt &gt;= 1) avg = sum / cnt; else avg = 0; // min_index 存储最接近的 下标 // min_diff 存储最接近的 差值 int min_index; double min_diff = 0x3f3f3f3f; for (int i = 0; i &lt; base_cnt; ++i) &#123; // diff 存储当前值 和 基准值的 差值 double diff = abs(avg - base[i]); // 更新最接近的 差值 和 下标 if (diff &lt; min_diff) &#123; min_diff = diff; min_index = i; &#125; &#125; printf(&quot;%5s\\t%9lf\\t%3d\\t%8s\\t%6.4lf%\\n&quot;, func_name.c_str(), avg, base[min_index], m[min_index].c_str(), (base[min_index] - min_diff) / base[min_index] * 100);&#125;int main()&#123; printf(&quot;%5s\\t%9s\\t%3s\\t%8s\\t%10s\\n&quot;, &quot;函数名&quot;, &quot;比率平均值&quot;, &quot;基准值&quot;, &quot;最接近的复杂度&quot;, &quot;可信度&quot;); solve(f1, &quot;f(1)&quot;); solve(f2, &quot;f(2)&quot;); solve(f3, &quot;f(3)&quot;); solve(f4, &quot;f(4)&quot;); solve(f5, &quot;f(5)&quot;); solve(f6, &quot;f(6)&quot;); return 0;&#125; 程序运行结果 1234567函数名 比率平均值 基准值 最接近的复杂度 可信度 f(1) 1.983659 2 O(n) 99.1830% f(2) 3.813990 4 O(n^2) 95.3498% f(3) 7.861286 8 O(n^3) 98.2661% f(4) 3.868134 4 O(n^2) 96.7034% f(5) 30.766667 32 O(n^5) 96.1458% f(6) 16.600542 16 O(n^4) 96.2466% 附注 该程序直接分析出 程序片段 的时间复杂度 暂时只支持O(n), O(n^2), O(n^3), O(n^4), O(n^5), O(n^6) 可以添加新的函数，但需要修改base数组和m数组","categories":[],"tags":[]},{"title":"将空格与换行分隔的表格转化为Markdown表格","slug":"将空格与换行分隔的表格转化为Markdown表格","date":"2024-10-15T01:28:27.000Z","updated":"2024-10-17T04:35:32.943Z","comments":true,"path":"2024/10/15/将空格与换行分隔的表格转化为Markdown表格/","link":"","permalink":"http://example.com/2024/10/15/%E5%B0%86%E7%A9%BA%E6%A0%BC%E4%B8%8E%E6%8D%A2%E8%A1%8C%E5%88%86%E9%9A%94%E7%9A%84%E8%A1%A8%E6%A0%BC%E8%BD%AC%E5%8C%96%E4%B8%BAMarkdown%E8%A1%A8%E6%A0%BC/","excerpt":"","text":"背景 写程序生成分析数据，一般会以空格与换行符分隔，导致Markdown无法识别，需要手动修改。 因此自己写一个工具程序，自动将空格与换行符分隔的表格转化为Markdown表格。 解决 直接上代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 将空格与换行分隔的表格转化为Markdown表格#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;sstream&gt;#include &lt;cctype&gt;using namespace std;int cnt = 0;void solve(const string &amp;line)&#123; istringstream iss(line); printf(&quot;|&quot;); string tmp; while (iss &gt;&gt; tmp) &#123; if (tmp == &quot;INF&quot;) printf(&quot; $\\\\infty$ |&quot;); else if (tmp[1] != &#x27;-&#x27;) printf(&quot; $%s$ |&quot;, tmp.c_str()); else printf(&quot; %s |&quot;, tmp.c_str()); ++cnt; &#125; printf(&quot;\\n&quot;);&#125;int main()&#123; // 请您将由空格和换行符分割的表格数据放在 table_in.txt 中 freopen(&quot;table_in.txt&quot;, &quot;r&quot;, stdin); // 处理后的Markdown表格数据输出到 table_out.md 中 freopen(&quot;table_out.md&quot;, &quot;w&quot;, stdout); string line; getline(cin, line); solve(line); line.clear(); while (cnt--) // 左对齐 &quot;:-------- &quot; // 居中 &quot;:--------: &quot; // 右对齐 &quot;--------: &quot; line += &quot;:--------: &quot;; solve(line); while (getline(cin, line)) solve(line); return 0;&#125; 例 源文本数据：（放在table_in.txt中） 12345678910111213141516171819202122232425262728 n O(n) O(n^2) O(n^3) O(n^2) O(n^5) O(n^4) 2 0 0 0 0 0 0 4 0 0 0 0 0 0 8 0 0 0 0 0 0 16 0 0 0 0 0 0 32 0 0 0 0 9 1 64 0 0 1 0 276 6 128 0 0 8 0 9110 96 256 0 1 60 1 INF 1357 512 0 1 433 0 INF 22904 1024 0 2 3682 1 INF INF 2048 0 14 INF 6 INF INF 4096 0 49 INF 24 INF INF 8192 0 178 INF 94 INF INF 16384 0 696 INF 343 INF INF 32768 0 2696 INF 1351 INF INF 65536 0 10743 INF 5350 INF INF 131072 0 INF INF INF INF INF 262144 0 INF INF INF INF INF 524288 3 INF INF INF INF INF 1048576 3 INF INF INF INF INF 2097152 7 INF INF INF INF INF 4194304 16 INF INF INF INF INF 8388608 26 INF INF INF INF INF16777216 58 INF INF INF INF INF33554432 99 INF INF INF INF INF67108864 181 INF INF INF INF INF 生成的Markdown表格Markdown表格Markdown表格如下：（从table_out.md中获取） 渲染前 1234567891011121314151617181920212223242526272829| $n$ | $O(n)$ | $O(n^2)$ | $O(n^3)$ | $O(n^2)$ | $O(n^5)$ | $O(n^4)$ || --------: | --------: | --------: | --------: | --------: | --------: | --------: || $2$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ || $4$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ || $8$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ || $16$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ || $32$ | $0$ | $0$ | $0$ | $0$ | $9$ | $1$ || $64$ | $0$ | $0$ | $1$ | $0$ | $276$ | $6$ || $128$ | $0$ | $0$ | $8$ | $0$ | $9110$ | $96$ || $256$ | $0$ | $1$ | $60$ | $1$ | $\\infty$ | $1357$ || $512$ | $0$ | $1$ | $433$ | $0$ | $\\infty$ | $22904$ || $1024$ | $0$ | $2$ | $3682$ | $1$ | $\\infty$ | $\\infty$ || $2048$ | $0$ | $14$ | $\\infty$ | $6$ | $\\infty$ | $\\infty$ || $4096$ | $0$ | $49$ | $\\infty$ | $24$ | $\\infty$ | $\\infty$ || $8192$ | $0$ | $178$ | $\\infty$ | $94$ | $\\infty$ | $\\infty$ || $16384$ | $0$ | $696$ | $\\infty$ | $343$ | $\\infty$ | $\\infty$ || $32768$ | $0$ | $2696$ | $\\infty$ | $1351$ | $\\infty$ | $\\infty$ || $65536$ | $0$ | $10743$ | $\\infty$ | $5350$ | $\\infty$ | $\\infty$ || $131072$ | $0$ | $\\infty$ | $\\infty$ | $\\infty$ | $\\infty$ | $\\infty$ || $262144$ | $0$ | $\\infty$ | $\\infty$ | $\\infty$ | $\\infty$ | $\\infty$ || $524288$ | $3$ | $\\infty$ | $\\infty$ | $\\infty$ | $\\infty$ | $\\infty$ || $1048576$ | $3$ | $\\infty$ | $\\infty$ | $\\infty$ | $\\infty$ | $\\infty$ || $2097152$ | $7$ | $\\infty$ | $\\infty$ | $\\infty$ | $\\infty$ | $\\infty$ || $4194304$ | $16$ | $\\infty$ | $\\infty$ | $\\infty$ | $\\infty$ | $\\infty$ || $8388608$ | $26$ | $\\infty$ | $\\infty$ | $\\infty$ | $\\infty$ | $\\infty$ || $16777216$ | $58$ | $\\infty$ | $\\infty$ | $\\infty$ | $\\infty$ | $\\infty$ || $33554432$ | $99$ | $\\infty$ | $\\infty$ | $\\infty$ | $\\infty$ | $\\infty$ || $67108864$ | $181$ | $\\infty$ | $\\infty$ | $\\infty$ | $\\infty$ | $\\infty$ | 渲染后 nnn O(n)O(n)O(n) O(n2)O(n^2)O(n2) O(n3)O(n^3)O(n3) O(n2)O(n^2)O(n2) O(n5)O(n^5)O(n5) O(n4)O(n^4)O(n4) 222 000 000 000 000 000 000 444 000 000 000 000 000 000 888 000 000 000 000 000 000 161616 000 000 000 000 000 000 323232 000 000 000 000 999 111 646464 000 000 111 000 276276276 666 128128128 000 000 888 000 911091109110 969696 256256256 000 111 606060 111 ∞\\infty∞ 135713571357 512512512 000 111 433433433 000 ∞\\infty∞ 229042290422904 102410241024 000 222 368236823682 111 ∞\\infty∞ ∞\\infty∞ 204820482048 000 141414 ∞\\infty∞ 666 ∞\\infty∞ ∞\\infty∞ 409640964096 000 494949 ∞\\infty∞ 242424 ∞\\infty∞ ∞\\infty∞ 819281928192 000 178178178 ∞\\infty∞ 949494 ∞\\infty∞ ∞\\infty∞ 163841638416384 000 696696696 ∞\\infty∞ 343343343 ∞\\infty∞ ∞\\infty∞ 327683276832768 000 269626962696 ∞\\infty∞ 135113511351 ∞\\infty∞ ∞\\infty∞ 655366553665536 000 107431074310743 ∞\\infty∞ 535053505350 ∞\\infty∞ ∞\\infty∞ 131072131072131072 000 ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ 262144262144262144 000 ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ 524288524288524288 333 ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ 104857610485761048576 333 ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ 209715220971522097152 777 ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ 419430441943044194304 161616 ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ 838860883886088388608 262626 ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ 167772161677721616777216 585858 ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ 335544323355443233554432 999999 ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ 671088646710886467108864 181181181 ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ ∞\\infty∞","categories":[],"tags":[]},{"title":"分析比较6个程序片段的时间复杂度","slug":"分析比较6个程序片段的时间复杂度","date":"2024-10-15T00:37:06.000Z","updated":"2024-10-15T01:49:38.215Z","comments":true,"path":"2024/10/15/分析比较6个程序片段的时间复杂度/","link":"","permalink":"http://example.com/2024/10/15/%E5%88%86%E6%9E%90%E6%AF%94%E8%BE%836%E4%B8%AA%E7%A8%8B%E5%BA%8F%E7%89%87%E6%AE%B5%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/","excerpt":"","text":"问题 给出了6个程序片段，分析它们的时间复杂度，并比较。 （程序片段直接放在后面的代码中） 解决 直接上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;iostream&gt;#include &lt;ctime&gt;using namespace std;// O(n)void f1(int N)&#123; int sum = 0; for (int i = 0; i &lt; N; ++i) ++sum;&#125;// O(n^2)void f2(int N)&#123; int sum = 0; for (int i = 0; i &lt; N; ++i) for (int j = 0; j &lt; N; ++j) ++sum;&#125;// O(n^3)void f3(int N)&#123; int sum = 0; for (int i = 0; i &lt; N; ++i) for (int j = 0; j &lt; N * N; ++j) ++sum;&#125;// O(n^2)void f4(int N)&#123; int sum = 0; for (int i = 0; i &lt; N; ++i) for (int j = 0; j &lt; i; ++j) ++sum;&#125;// O(n^5)void f5(int N)&#123; int sum = 0; for (int i = 0; i &lt; N; ++i) for (int j = 0; j &lt; i * i; ++j) for (int k = 0; k &lt; j; ++k) ++sum;&#125;// O(n^4)void f6(int N)&#123; int sum = 0; for (int i = 0; i &lt; N; ++i) for (int j = 0; j &lt; i * i; ++j) if (j % i == 0) for (int k = 0; k &lt; j; ++k) ++sum;&#125;const int INF = 2147483647;void print(clock_t t)&#123; if (t == INF) printf(&quot;\\t%5s&quot;, &quot;INF&quot;); else printf(&quot;\\t%5ld&quot;, t);&#125;void solve(void (*f)(int), int n, int maxn)&#123; clock_t s = 0, e = 0; if (n &lt;= maxn) &#123; s = clock(); f(n); e = clock(); &#125; else e = INF; print(e - s);&#125;int main()&#123; printf(&quot;%8s&quot;, &quot;n&quot;); printf(&quot;\\t O(n)\\tO(n^2)\\tO(n^3)\\tO(n^2)\\tO(n^5)\\tO(n^4)\\n&quot;); for (int n = 2; n &lt;= 100000000; n *= 2) &#123; printf(&quot;%8d&quot;, n); solve(f1, n, 100000000); solve(f2, n, 65536); solve(f3, n, 1024); solve(f4, n, 65536); solve(f5, n, 128); solve(f6, n, 512); printf(&quot;\\n&quot;); &#125; return 0;&#125; 运行程序输出：（处理成MarkdownMarkdownMarkdown表格形式） nnn O(n)O(n)O(n) O(n2)O(n^2)O(n2) O(n3)O(n^3)O(n3) O(n2)O(n^2)O(n2) O(n5)O(n^5)O(n5) O(n4)O(n^4)O(n4) 222 000 000 000 000 000 000 444 000 000 000 000 000 000 888 000 000 000 000 000 000 161616 000 000 000 000 000 000 323232 000 000 000 000 999 111 646464 000 000 111 000 276276276 666 128128128 000 000 888 000 911091109110 969696 256256256 000 111 606060 111 ∞\\infty∞ 135713571357 512512512 000 111 433433433 000 ∞\\infty∞ 229042290422904 102410241024 000 222 368236823682 111 ∞\\infty∞ ∞\\infty∞ 204820482048 000 141414 ∞\\infty∞ 666 ∞\\infty∞ ∞\\infty∞ 409640964096 000 494949 ∞\\infty∞ 242424 ∞\\infty∞ ∞\\infty∞ 819281928192 000 178178178 ∞\\infty∞ 949494 ∞\\infty∞ ∞\\infty∞ 163841638416384 000 696696696 ∞\\infty∞ 343343343 ∞\\infty∞ ∞\\infty∞ 327683276832768 000 269626962696 ∞\\infty∞ 135113511351 ∞\\infty∞ ∞\\infty∞ 655366553665536 000 107431074310743 ∞\\infty∞ 535053505350 ∞\\infty∞ ∞\\infty∞ 131072131072131072 000 ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ 262144262144262144 000 ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ 524288524288524288 333 ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ 104857610485761048576 333 ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ 209715220971522097152 777 ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ 419430441943044194304 161616 ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ 838860883886088388608 262626 ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ 167772161677721616777216 585858 ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ 335544323355443233554432 999999 ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ 671088646710886467108864 181181181 ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ ∞\\infty∞ 分析 在试验前分析f(1),f(2),f(3),f(4),f(5),f(6)f(1), f(2), f(3), f(4), f(5), f(6)f(1),f(2),f(3),f(4),f(5),f(6)的时间复杂度分别为：O(n),O(n2),O(n3),O(n2),O(n5),O(n4)O(n), O(n^2), O(n^3), O(n^2), O(n^5), O(n^4)O(n),O(n2),O(n3),O(n2),O(n5),O(n4)。 且我们知道，当nnn扩大一倍时，O(n)O(n)O(n)程序运行时间约乘以因子222，O(n2)O(n^2)O(n2)程序运行时间约乘以因子444，O(n3)O(n^3)O(n3)程序运行时间约乘以因子888，O(n4)O(n^4)O(n4)程序运行时间约乘以因子161616，O(n5)O(n^5)O(n5)程序运行时间约乘以因子323232。 结论 通过试验可以观察到，实际运行时间与通过分析所描述的运行时间相匹配。","categories":[],"tags":[]},{"title":"LaTeX练习008","slug":"LaTeX练习008","date":"2024-10-14T13:09:05.000Z","updated":"2024-10-14T13:28:21.676Z","comments":true,"path":"2024/10/14/LaTeX练习008/","link":"","permalink":"http://example.com/2024/10/14/LaTeX%E7%BB%83%E4%B9%A0008/","excerpt":"","text":"问题 求两个函数f(N)f(N)f(N)和g(N)g(N)g(N)，使得f(N)≠O(g(N))f(N) \\neq O(g(N))f(N)​=O(g(N))且 g(N)≠O(f(N))g(N) \\neq O(f(N))g(N)​=O(f(N)) 解答 若 f(N)=O(g(N))f(N) = O(g(N))f(N)=O(g(N))，则说明 f(N)f(N)f(N) 的增长率小于等于 (≤)(\\le)(≤) g(N)g(N)g(N) 的增长率。 若 g(N)=O(f(N))g(N) = O(f(N))g(N)=O(f(N))，则说明 g(N)g(N)g(N) 的增长率小于等于 (≤)(\\le)(≤) f(N)f(N)f(N) 的增长率。 然而题目要求都不等于，所以需要找到两个函数，使得随着 N→∞N \\to \\inftyN→∞ 时，两者的增长率不能稳定的分出高低。 也就是说，使得极限lim⁡N→∞f(N)/g(N)\\lim\\limits_{N \\to \\infty} f(N) / g(N)N→∞lim​f(N)/g(N) 在N→∞N \\to \\inftyN→∞ 时不断振荡，不能收敛或是正负无穷大 ±∞\\pm\\infty±∞。 例一： f(N)=sin⁡Ng(N)=cos⁡Nf(N) = \\sin N \\\\ g(N) = \\cos Nf(N)=sinNg(N)=cosN ∵lim⁡x→∞sin⁡xcos⁡x=lim⁡x→∞tan⁡x \\because \\lim\\limits_{x \\to \\infty} \\frac{\\sin x}{\\cos x} = \\lim\\limits_{x \\to \\infty} \\tan x ∵x→∞lim​cosxsinx​=x→∞lim​tanx 函数(tan⁡x\\tan xtanx)是周期函数，其周期为(π\\piπ)。即(tan⁡(x+kπ)=tan⁡x\\tan(x + k\\pi) = \\tan xtan(x+kπ)=tanx)，其中(kkk)为任意整数。 因此，随着(xxx)的增加，(tan⁡x\\tan xtanx)的值会再(−∞-\\infty−∞)到(+∞+\\infty+∞)之间不断变化。 函数(tan⁡x\\tan xtanx)在(x=π2+kπx = \\frac{\\pi}{2} + k\\pix=2π​+kπ)（其中(kkk)是整数）时是未定义的，因为这些点是(tan⁡x\\tan xtanx)的垂直渐近线。 在上面这些点附近，(tan⁡x\\tan xtanx)的值会趋向于(±∞\\pm\\infty±∞)。 由于(tan⁡x\\tan xtanx)的值在每个周期内都会从(−∞-\\infty−∞)变到(+∞+\\infty+∞)，并且在无穷远处没有收敛的趋势，因此(tan⁡x\\tan xtanx)在(x→∞x \\to \\inftyx→∞)时没有确定的极限。 由于 (tan⁡x\\tan xtanx) 在 (x→∞x \\to \\inftyx→∞) 时没有收敛到任何有限或无限的值，因此极限(lim⁡x→∞tan⁡x\\lim\\limits_{x \\to \\infty} \\tan xx→∞lim​tanx) 不存在。 这是因为 (\\tan x) 的值在每个周期内都会无限振荡，没有趋向于任何固定的值。 因此该例满足条件。 例二： f(N)={1if N is even,Nif N is odd. f(N) = \\begin{cases} 1 &amp; \\text{if N is even}, \\\\ N &amp; \\text{if N is odd}. \\\\ \\end{cases} \\\\ f(N)={1N​if N is even,if N is odd.​ g(N)={1if N is odd,Nif N is even. g(N) = \\left\\{ \\begin{array}{lr} 1 &amp; \\text{if N is odd}, \\\\ N &amp; \\text{if N is even}. \\end{array} \\right. g(N)={1N​if N is odd,if N is even.​ 同例一，lim⁡N→∞f(N)/g(N)\\lim\\limits_{N \\to \\infty} f(N) / g(N)N→∞lim​f(N)/g(N) 在000 和∞\\infty∞ 之间震荡。 因此该例满足条件。 附注 \\pi 表示 π\\piπ \\neq 表示不等 ≠\\neq​= ratio 比，比率 使用cases或者array 环境来定义分段函数。 参考链接 The Short Introduction to LaTeX2e\\LaTeX 2eLATE​X2e (Chinese Simplified) KaTeX\\KaTeXKATE​X 数学公式大全 KaTeX\\KaTeXKATE​X 支持的数学操作 官方","categories":[],"tags":[]},{"title":"hexo 修改文章标题后404问题","slug":"hexo-修改文章标题后404问题","date":"2024-10-13T14:56:03.000Z","updated":"2024-10-13T15:05:09.009Z","comments":true,"path":"2024/10/13/hexo-修改文章标题后404问题/","link":"","permalink":"http://example.com/2024/10/13/hexo-%E4%BF%AE%E6%94%B9%E6%96%87%E7%AB%A0%E6%A0%87%E9%A2%98%E5%90%8E404%E9%97%AE%E9%A2%98/","excerpt":"","text":"背景 想将之前LaTeX练习00x系列的文章名中LaTex修改为 LaTeX，但修改后文章却无法访问（404）。 经查阅一些资料，原来git 检查不到文件名大小写的变更，默认设置为忽略文件名大小写。 解决办法 将文件名修改为另外的名字，hexo d提交后 再将文件名改成一开始想要修改的名字，再次提交即可解决。","categories":[],"tags":[]},{"title":"LaTeX练习007","slug":"LaTeX练习007","date":"2024-10-13T12:09:14.000Z","updated":"2024-10-13T14:30:57.763Z","comments":true,"path":"2024/10/13/LaTeX练习007/","link":"","permalink":"http://example.com/2024/10/13/LaTeX%E7%BB%83%E4%B9%A0007/","excerpt":"","text":"问题 证明对任意常数kkk，log⁡kN=o(N)\\log^k N = o(N)logkN=o(N)。 解答 考虑极限的形式:我们需要证明(lim⁡N→∞log⁡kNN=0)。应用洛必达法则:因为直接计算这个极限可能不容易。我们可以利用洛必达法则（L′Ho^pital′sRule），它适用于形式为(∞∞)或(00)的极限问题。这里我们有一个(∞∞)的情况。多次求导:对于(log⁡kNN)，连续地对分子和分母求导(k+1)次。每次对数的导数会降低其幂次，而线性项(N)的导数始终是常数或增加的幂次。极限结果:经过(k+1)次求导后，考虑极限的形式: 我们需要证明 (\\lim_{N \\to \\infty} \\frac{\\log^k N}{N} = 0)。\\\\ 应用洛必达法则: 因为直接计算这个极限可能不容易。\\\\ 我们可以利用洛必达法则（L&#x27;Hôpital&#x27;s Rule），它适用于形式为 (\\frac{\\infty}{\\infty}) 或 (\\frac{0}{0}) 的极限问题。\\\\这里我们有一个 (\\frac{\\infty}{\\infty}) 的情况。\\\\ 多次求导: 对于 (\\frac{\\log^k N}{N})，连续地对分子和分母求导 (k+1) 次。\\\\ 每次对数的导数会降低其幂次，而线性项 (N) 的导数始终是常数或增加的幂次。\\\\ 极限结果: 经过 (k+1) 次求导后，\\\\ 考虑极限的形式:我们需要证明(N→∞lim​NlogkN​=0)。应用洛必达法则:因为直接计算这个极限可能不容易。我们可以利用洛必达法则（L′Ho^pital′sRule），它适用于形式为(∞∞​)或(00​)的极限问题。这里我们有一个(∞∞​)的情况。多次求导:对于(NlogkN​)，连续地对分子和分母求导(k+1)次。每次对数的导数会降低其幂次，而线性项(N)的导数始终是常数或增加的幂次。极限结果:经过(k+1)次求导后， lim⁡N→∞log⁡kNN=lim⁡N→∞(log⁡kN)′N′=lim⁡N→∞k⋅log⁡k−1NNln⁡a（a为底数）=lim⁡N→∞k(k−1)⋅log⁡k−2NNln⁡2a=lim⁡N→∞k(k−1)(k−2)⋅log⁡k−3NNln⁡3a⋮=lim⁡N→∞k(k−1)(k−2)⋯2⋅log⁡NNln⁡k−1a=lim⁡N→∞k!Nln⁡ka=lim⁡N→∞0ln⁡ka=0\\begin{aligned} \\lim_{N \\to \\infty} \\frac {\\log^k N}{N} &amp;= \\lim_{N \\to \\infty} \\frac {(\\log^k N)^{\\prime}}{N^{\\prime}} \\\\ &amp; = \\lim_{N \\to \\infty} k \\cdot \\frac {\\log^{k-1} N}{N \\ln a} \\quad （a为底数）\\\\ &amp; = \\lim_{N \\to \\infty} k(k-1) \\cdot \\frac {\\log^{k-2} N}{N \\ln^{2} a} \\\\ &amp; = \\lim_{N \\to \\infty} k(k-1)(k-2) \\cdot \\frac {\\log^{k-3} N}{N \\ln^{3} a} \\\\ &amp; \\qquad \\vdots \\\\ &amp; = \\lim_{N \\to \\infty} k(k-1)(k-2)\\cdots 2 \\cdot \\frac {\\log N}{N \\ln^{k-1} a} \\\\ &amp; = \\lim_{N \\to \\infty} \\frac {k!}{N \\ln^{k} a} \\\\ &amp; = \\lim_{N \\to \\infty} \\frac {0}{\\ln^{k} a} \\\\ &amp; = 0 \\\\ \\end{aligned} N→∞lim​NlogkN​​=N→∞lim​N′(logkN)′​=N→∞lim​k⋅Nlnalogk−1N​（a为底数）=N→∞lim​k(k−1)⋅Nln2alogk−2N​=N→∞lim​k(k−1)(k−2)⋅Nln3alogk−3N​⋮=N→∞lim​k(k−1)(k−2)⋯2⋅Nlnk−1alogN​=N→∞lim​Nlnkak!​=N→∞lim​lnka0​=0​ 分子最终将变为一个常数（因为(log⁡kN)的(k+1)阶导数将会是(0)）而分母是(ln⁡a)的某个正幂次。因此，当(N→∞)时，这个比值趋向于(0)。结论:由此我们得出(lim⁡N→∞log⁡kNN=0)，即(log⁡kN=o(N))。分子最终将变为一个常数（因为 (\\log^k N) 的 (k+1) 阶导数将会是 (0)）\\\\ 而分母是 (\\ln a) 的某个正幂次。\\\\ 因此，当 (N \\to \\infty) 时，这个比值趋向于 (0)。\\\\ 结论: 由此我们得出 (\\lim_{N \\to \\infty} \\frac{\\log^k N}{N} = 0)，即 (\\log^k N = o(N))。 分子最终将变为一个常数（因为(logkN)的(k+1)阶导数将会是(0)）而分母是(lna)的某个正幂次。因此，当(N→∞)时，这个比值趋向于(0)。结论:由此我们得出(N→∞lim​NlogkN​=0)，即(logkN=o(N))。 附注 这个证明展示了即使是增长非常缓慢的对数函数的任何常数次幂，在 (N) 趋向无穷大时，其增长速度仍然远低于任何线性函数的增长速度。这在分析算法复杂度时非常重要，特别是在比较不同类型的算法效率时。 f^&#123;'&#125;(x) 表示 f(x)f(x)f(x) 的导数 f′(x)f^{&#x27;}(x)f′(x) \\prime 表示撇 ′\\prime′ f^&#123;\\prime&#125;(x) 也可表示 f(x)f(x)f(x) 的导数 f′(x)f^{\\prime}(x)f′(x) (log⁡ax)′=1xln⁡a\\displaystyle (\\log_a x)^{&#x27;} = \\frac {1} {x \\ln a}(loga​x)′=xlna1​ \\vdots 表示省略号 ⋮\\vdots⋮ \\LaTeX 表示 LaTeX\\LaTeXLATE​X \\KaTeX 表示 KaTeX\\KaTeXKATE​X 参考链接 The Short Introduction to LaTeX2e\\LaTeX 2eLATE​X2e (Chinese Simplified) KaTeX\\KaTeXKATE​X 数学公式大全 KaTeX\\KaTeXKATE​X 支持的数学操作 官方","categories":[],"tags":[]},{"title":"LaTeX练习006","slug":"LaTeX练习006","date":"2024-10-13T09:52:12.000Z","updated":"2024-10-13T14:32:22.091Z","comments":true,"path":"2024/10/13/LaTeX练习006/","link":"","permalink":"http://example.com/2024/10/13/LaTeX%E7%BB%83%E4%B9%A0006/","excerpt":"","text":"问题 那个函数增长的更快？Nlog⁡NN\\log NNlogN，N1+ϵlog⁡NN^{1 + \\frac{\\epsilon}{\\sqrt{\\log N}}}N1+logN​ϵ​ (ϵ&gt;0)(\\epsilon &gt; 0)(ϵ&gt;0) 解答 lim⁡N→∞Nlog⁡NN1+ϵ/log⁡N=lim⁡N→∞log⁡NNϵ/log⁡N\\begin{aligned} \\lim_{N\\to\\infty} \\frac {N\\log N}{N^{1+\\epsilon / \\sqrt{\\log N}}} = \\lim_{N\\to\\infty} \\frac {\\log N}{N^{\\epsilon / \\sqrt{\\log N}}} \\end{aligned} N→∞lim​N1+ϵ/logN​NlogN​=N→∞lim​Nϵ/logN​logN​​ 求lim⁡N→∞log⁡NNϵ/log⁡N令(x=log⁡N)，则(N=ex)。当(N→∞)时，(x→∞)。∴lim⁡N→∞log⁡NNϵ/log⁡N=lim⁡x→∞x(ex)ϵ/x我们知道((ex)ϵ/x=ex⋅ϵx=eϵx)。∴lim⁡x→∞x(ex)ϵ/x=lim⁡x→∞xeϵx考虑(x→∞)时，(eϵx)的增长速度远大于(x)的增长速度。具体来说，(eϵx)的增长速度是指数级的，而(x)的增长速度是多项式的。因此，当(x→∞)时，(eϵx)趋向于无穷大，而(x)相对于(eϵx)趋近于0。∴lim⁡x→∞xeϵx=0求 \\lim_{N \\to \\infty} \\frac{\\log N}{N^{\\epsilon / \\sqrt{\\log N}}} \\\\ 令 (x = \\log N)，则 (N = e^x)。当 (N \\to \\infty) 时，(x \\to \\infty)。\\\\ \\therefore \\lim_{N \\to \\infty} \\frac{\\log N}{N^{\\epsilon / \\sqrt{\\log N}}} = \\lim_{x \\to \\infty} \\frac{x}{(e^x)^{\\epsilon / \\sqrt{x}}} \\\\ 我们知道 ((e^x)^{\\epsilon / \\sqrt{x}} = e^{x \\cdot \\frac{\\epsilon}{\\sqrt{x}}} = e^{\\epsilon \\sqrt{x}})。\\\\ \\therefore \\lim_{x \\to \\infty} \\frac{x}{(e^x)^{\\epsilon / \\sqrt{x}}} = \\lim_{x \\to \\infty} \\frac{x}{e^{\\epsilon \\sqrt{x}}}\\\\ 考虑 (x \\to \\infty) 时，(e^{\\epsilon \\sqrt{x}}) 的增长速度远大于 (x) 的增长速度。\\\\ 具体来说，(e^{\\epsilon \\sqrt{x}}) 的增长速度是指数级的，而 (x) 的增长速度是多项式的。\\\\ 因此，当 (x \\to \\infty) 时，(e^{\\epsilon \\sqrt{x}}) 趋向于无穷大，而 (x) 相对于 (e^{\\epsilon \\sqrt{x}}) 趋近于 0。\\\\ \\therefore \\lim_{x \\to \\infty} \\frac{x}{e^{\\epsilon \\sqrt{x}}} = 0 求N→∞lim​Nϵ/logN​logN​令(x=logN)，则(N=ex)。当(N→∞)时，(x→∞)。∴N→∞lim​Nϵ/logN​logN​=x→∞lim​(ex)ϵ/x​x​我们知道((ex)ϵ/x​=ex⋅x​ϵ​=eϵx​)。∴x→∞lim​(ex)ϵ/x​x​=x→∞lim​eϵx​x​考虑(x→∞)时，(eϵx​)的增长速度远大于(x)的增长速度。具体来说，(eϵx​)的增长速度是指数级的，而(x)的增长速度是多项式的。因此，当(x→∞)时，(eϵx​)趋向于无穷大，而(x)相对于(eϵx​)趋近于0。∴x→∞lim​eϵx​x​=0 因此，当 N→∞N\\to\\inftyN→∞ 时，Nlog⁡NN\\log NNlogN 的增长速度比 N1+ϵlog⁡NN^{1 + \\frac{\\epsilon}{\\sqrt{\\log N}}}N1+logN​ϵ​ 的增长速度要快。 附注 \\epsilon 表示数学符号 ϵ\\epsilonϵ \\to 表示箭头 →\\to→ \\lim 表示极限 lim⁡\\limlim 参考链接 The Short Introduction to LaTeX2e (Chinese Simplified)","categories":[],"tags":[]},{"title":"LaTeX练习005","slug":"LaTeX练习005","date":"2024-10-12T03:30:57.000Z","updated":"2024-10-13T14:32:44.273Z","comments":true,"path":"2024/10/12/LaTeX练习005/","link":"","permalink":"http://example.com/2024/10/12/LaTeX%E7%BB%83%E4%B9%A0005/","excerpt":"","text":"问题 令FiF_iFi​是斐波那契数。证明下列各式： a.∑i=1NFi=FN+2−2 a. \\quad \\displaystyle \\sum\\limits_{i=1}^{N} F_i = F_{N+2} - 2 a.i=1∑N​Fi​=FN+2​−2 b.FN&lt;ϕN,其中ϕ=(1+5)/2 b. \\quad \\displaystyle F_N &lt; \\phi^N , 其中\\phi = (1+\\sqrt{5}) / 2 b.FN​&lt;ϕN,其中ϕ=(1+5​)/2 解答 斐波那契数列的递推关系是： Fi=Fi−1+Fi−2F0=1,F1=1,F2=2,F3=3,F4=5,⋯ F_{i} = F_{i-1} + F_{i-2} \\\\ F_{0} = 1, F_{1} = 1, F_{2} = 2, F_{3} = 3, F_{4} = 5, \\cdots Fi​=Fi−1​+Fi−2​F0​=1,F1​=1,F2​=2,F3​=3,F4​=5,⋯ a.用数学归纳法，当N=1或2时，显然成立所以有假设∑i=1NFi=FN+2−2 a. \\quad 用数学归纳法，当N=1或2时，显然成立 \\\\ \\qquad 所以有假设 \\sum\\limits_{i=1}^{N} F_i = F_{N+2} - 2 \\\\ a.用数学归纳法，当N=1或2时，显然成立所以有假设i=1∑N​Fi​=FN+2​−2 ∴∑i=1N+1Fi=∑i=1NFi+FN+1=FN+2−2+FN+1=FN+2+FN+1−2=FN+3−2=F(N+1)+2−2即证！\\begin{aligned} \\qquad \\therefore \\sum\\limits_{i=1}^{N+1} F_i &amp; = \\sum\\limits_{i=1}^{N} F_i + F_{N+1} \\hspace{100cm}\\\\ &amp; = F_{N+2} - 2 + F_{N+1} \\\\ &amp; = F_{N+2} + F_{N+1} - 2 \\\\ &amp; = F_{N+3} - 2 \\\\ &amp; = F_{(N+1) + 2} - 2 \\\\ 即证！ \\end{aligned} ∴i=1∑N+1​Fi​即证！​=i=1∑N​Fi​+FN+1​=FN+2​−2+FN+1​=FN+2​+FN+1​−2=FN+3​−2=F(N+1)+2​−2​ b.∵φ=(1+5)/2∴φ2=(1+52)2=1+5+254=3+52=φ+1\\begin{aligned} b.\\because \\varphi &amp; = (1+\\sqrt{5}) / 2 \\hspace {100cm}\\\\ \\therefore \\varphi^2 &amp; = \\left(\\frac {1 + \\sqrt{5}}{2}\\right)^2 \\\\ &amp; = \\frac {1 + 5 + 2\\sqrt{5}}{4} \\\\ &amp; = \\frac {3 + \\sqrt{5}}{2} = \\varphi + 1 \\\\ \\end{aligned} b.∵φ∴φ2​=(1+5​)/2=(21+5​​)2=41+5+25​​=23+5​​=φ+1​ ∴φ+1=φ2∴(φ+1)⋅φ−2=φ2⋅φ−2∴φ−1+φ−2=1\\begin{aligned} \\quad &amp; \\therefore \\varphi + 1 = \\varphi^2 \\hspace{100cm}\\\\ &amp; \\therefore (\\varphi + 1) \\cdot \\varphi^{-2} = \\varphi^2 \\cdot \\varphi^{-2} \\\\ &amp; \\therefore \\boxed{ \\varphi^{-1} + \\varphi^{-2} = 1} \\\\ \\end{aligned} ​∴φ+1=φ2∴(φ+1)⋅φ−2=φ2⋅φ−2∴φ−1+φ−2=1​​ 用数学归纳法，当N=1和N=2时，显然成立。所以有假设FN&lt;φN且FN−1&lt;φN−1 \\quad 用数学归纳法，当 N=1 和N=2 时，显然成立。\\\\ \\quad 所以有假设 F_N &lt; \\varphi^N 且 F_{N-1}&lt; \\varphi^{N-1}\\\\ 用数学归纳法，当N=1和N=2时，显然成立。所以有假设FN​&lt;φN且FN−1​&lt;φN−1 FN+1=FN+FN−1&lt;φN+φN−1&lt;φ−1φN+1+φ−2φN+1&lt;(φ−1+φ−2)φN+1&lt;φN+1即证！\\begin{aligned} F_{N+1} &amp; = F_N + F_{N-1} \\hspace{100cm} \\\\ &amp; &lt; \\varphi^N + \\varphi^{N-1} \\\\ &amp; &lt; \\varphi^{-1}\\varphi^{N+1} + \\varphi^{-2} \\varphi^{N+1} \\\\ &amp; &lt; (\\varphi^{-1} + \\varphi^{-2})\\varphi^{N+1} \\\\ &amp; &lt; \\varphi^{N+1} \\\\ 即证！ \\end{aligned} FN+1​即证！​=FN​+FN−1​&lt;φN+φN−1&lt;φ−1φN+1+φ−2φN+1&lt;(φ−1+φ−2)φN+1&lt;φN+1​ 附注 \\phi 是一个数学符号 ϕ\\phiϕ。 \\varphi 是一个数学符号 φ\\varphiφ。 参考链接 The Short Introduction to LaTeX2e (Chinese Simplified)","categories":[],"tags":[]},{"title":"LaTeX练习004","slug":"LaTeX练习004","date":"2024-10-12T03:27:45.000Z","updated":"2024-10-13T14:32:58.940Z","comments":true,"path":"2024/10/12/LaTeX练习004/","link":"","permalink":"http://example.com/2024/10/12/LaTeX%E7%BB%83%E4%B9%A0004/","excerpt":"","text":"问题 a.∑i=0∞14ia. \\displaystyle\\quad\\sum\\limits_{i=0}^{\\infty} \\frac {1}{4^i}a.i=0∑∞​4i1​ b.∑i=0∞i4ib. \\displaystyle\\quad\\sum\\limits_{i=0}^{\\infty} \\frac {i}{4^i}b.i=0∑∞​4ii​ c.∑i=0∞i24ic. \\displaystyle\\quad\\sum\\limits_{i=0}^{\\infty} \\frac {i^2}{4^i}c.i=0∑∞​4ii2​ d.∑i=0∞iN4id. \\displaystyle\\quad \\sum\\limits_{i=0}^{\\infty} \\frac {i^N}{4^i}d.i=0∑∞​4iiN​ 解答 a.∑i=0∞14i=∑i=0∞(14)i=11−14=43\\begin{aligned} a. \\quad\\sum\\limits_{i=0}^{\\infty} \\frac {1}{4^i} &amp; = \\sum\\limits_{i=0}^{\\infty} \\left(\\frac {1}{4} \\right)^i \\hspace{100cm} \\\\ &amp; = \\frac {1}{\\displaystyle 1 - \\frac {1}{4}} \\\\ &amp; = \\boxed{\\frac {4}{3}} \\end{aligned} a.i=0∑∞​4i1​​=i=0∑∞​(41​)i=1−41​1​=34​​​ b.令S=∑i=0∞i4i=14+242+343+⋯则4S=1+24+342+⋯上面两式子相减得：(这种运算只能对收敛级数进行)3S=1+14+142+⋯=∑i=0∞14i=43∴S=49\\begin{aligned} b. \\quad 令S = \\sum\\limits_{i=0}^{\\infty} \\frac {i}{4^i} &amp; = \\frac {1}{4} + \\frac {2}{4^2} + \\frac {3}{4^3} + \\cdots \\hspace{100cm} \\\\ 则4S \\qquad \\qquad &amp; = 1 + \\frac {2}{4} + \\frac {3}{4^2} + \\cdots \\\\ 上面两式子相减 得&amp;：(这种运算只能对收敛级数进行) \\\\ 3S \\qquad \\qquad &amp; = 1 + \\frac {1}{4} + \\frac {1}{4^2} + \\cdots \\\\ &amp; = \\sum\\limits_{i=0}^{\\infty} \\frac {1}{4^i} \\\\ &amp; = \\frac {4}{3} \\\\ \\therefore \\boxed{S = \\frac {4}{9}} \\end{aligned} b.令S=i=0∑∞​4ii​则4S上面两式子相减得3S∴S=94​​​=41​+422​+433​+⋯=1+42​+423​+⋯：(这种运算只能对收敛级数进行)=1+41​+421​+⋯=i=0∑∞​4i1​=34​​ c.S=∑i=0∞i24i=14+2242+3243+⋯4S=1+224+3242+4243+⋯上面两式子相减得：(这种运算只能对收敛级数进行)3S=1+34+542+743+⋯=∑i=0∞2i+14i=2∑i=0∞i4i+∑i=0∞14i=2×49+43=209∴S=2027\\begin{aligned} c. \\quad S = \\sum\\limits_{i=0}^{\\infty} \\frac {i^2}{4^i} &amp; = \\frac {1}{4} + \\frac {2^2}{4^2} + \\frac {3^2}{4^3} + \\cdots \\hspace{100cm} \\\\ 4S &amp; = 1 + \\frac {2^2}{4} + \\frac {3^2}{4^2} + \\frac {4^2}{4^3} + \\cdots \\\\ 上面两式子相减 得&amp;：(这种运算只能对收敛级数进行) \\\\ 3S &amp; = 1 + \\frac {3}{4} + \\frac {5}{4^2} + \\frac {7}{4^3} + \\cdots \\\\ &amp; = \\sum\\limits_{i=0}^{\\infty} \\frac {2i + 1}{4^i} \\\\ &amp; = 2\\sum\\limits_{i=0}^{\\infty} \\frac {i}{4^i} + \\sum\\limits_{i=0}^{\\infty} \\frac {1}{4^i} \\\\ &amp; = 2 \\times \\frac {4}{9} + \\frac {4}{3} \\\\ &amp; = \\frac {20}{9} \\\\ \\therefore \\boxed {S = \\frac {20}{27}} \\end{aligned} c.S=i=0∑∞​4ii2​4S上面两式子相减得3S∴S=2720​​​=41​+4222​+4332​+⋯=1+422​+4232​+4342​+⋯：(这种运算只能对收敛级数进行)=1+43​+425​+437​+⋯=i=0∑∞​4i2i+1​=2i=0∑∞​4ii​+i=0∑∞​4i1​=2×94​+34​=920​​ d.∑i=0∞iN4i暂未找到解法!d. \\displaystyle\\quad \\sum\\limits_{i=0}^{\\infty} \\frac {i^N}{4^i} \\hspace{100cm} \\\\ 暂未找到解法! \\hspace{100cm} d.i=0∑∞​4iiN​暂未找到解法! 附注 S=∑i=0∞Ai(0&lt;A&lt;1)S = \\sum\\limits_{i=0}^{\\infty} A^i \\quad (0&lt;A&lt;1)S=i=0∑∞​Ai(0&lt;A&lt;1) 有 S=11−AS = \\displaystyle\\frac{1}{1-A}S=1−A1​ 使用 \\left 和 \\right 命令可令括号（定界符）的大小可变。LATEX 会 自动根据括号内的公式大小决定定界符大小。\\left 和 \\right 必须成对使用。需要使用单个定 界符时，另一个定界符写成 \\left. 或 \\right.。 \\displaystyle 表示 行间公式尺寸 \\quad 表示空格 \\quad \\infty 表示无穷大 ∞\\infty∞ \\notag 表示不显示公式编号 \\times 表示乘号 ×\\times× \\cdot 表示点号 ⋅\\cdot⋅ \\cdots 表示省略号 ⋯\\cdots⋯ \\boxed 表示用盒子括住公式1+2+3\\boxed {1+2+3}1+2+3​ KaTex 不支持 \\begin&#123;align&#125; 和 \\end&#123;align&#125;，当然也不支持 \\notag 啦。 参考链接 The Short Introduction to LaTeX2e (Chinese Simplified) KaTex不支持 \\begin{align} 让hexo支持LaTeX公式","categories":[],"tags":[]},{"title":"LaTeX练习003","slug":"LaTeX练习003","date":"2024-10-12T03:27:07.000Z","updated":"2024-10-13T14:33:14.729Z","comments":true,"path":"2024/10/12/LaTeX练习003/","link":"","permalink":"http://example.com/2024/10/12/LaTeX%E7%BB%83%E4%B9%A0003/","excerpt":"","text":"问题 估计 ∑i=⌊N/2⌋N1i\\sum\\limits_{i=\\lfloor {N/2} \\rfloor}^N \\frac{1}{i} \\hspace{100cm} i=⌊N/2⌋∑N​i1​ 解答 ∑i=⌊N/2⌋N1i=∑i=1N1i−∑i=1⌊N/2−1⌋1i≈ln⁡N−ln⁡N2≈ln⁡2\\begin{aligned} \\sum\\limits_{i=\\lfloor {N/2} \\rfloor}^N \\frac{1}{i} &amp; = \\sum\\limits_{i=1}^{N} \\frac {1}{i} - \\sum\\limits_{i=1}^{\\lfloor N/2-1 \\rfloor} \\frac {1}{i} \\hspace{100cm} \\\\ &amp; \\approx \\ln N - \\ln \\frac {N}{2} \\\\ &amp; \\approx \\ln 2 \\end{aligned} i=⌊N/2⌋∑N​i1​​=i=1∑N​i1​−i=1∑⌊N/2−1⌋​i1​≈lnN−ln2N​≈ln2​ 附注 ∑i=1N1i≈ln⁡N\\sum\\limits_{i=1}^{N} \\frac {1}{i} \\approx \\ln Ni=1∑N​i1​≈lnN \\lfloor 表示左下界符号⌊\\lfloor⌊ \\rfloor 表示右下界符号⌋\\rfloor⌋ \\approx 表示约等于≈\\approx≈ \\ln 表示对数ln⁡\\lnln 参考链接 The Short Introduction to LaTeX2e (Chinese Simplified)","categories":[],"tags":[]},{"title":"LaTeX练习002","slug":"LaTeX练习002","date":"2024-10-12T03:25:37.000Z","updated":"2024-10-13T14:54:15.822Z","comments":true,"path":"2024/10/12/LaTeX练习002/","link":"","permalink":"http://example.com/2024/10/12/LaTeX%E7%BB%83%E4%B9%A0002/","excerpt":"","text":"问题 2100(mod5)2^{100}\\pmod 52100(mod5) 的值是多少？ 解答 ∵24=16≡1(mod5).∴2100(mod5)=(24)25≡125(mod5).∴2100(mod5)≡1(mod5).\\begin{aligned} &amp; \\because 2^4 = 16\\equiv 1 \\pmod 5. \\hspace{100cm}\\\\ &amp; \\therefore 2^{100} \\pmod 5 = (2^4)^{25} \\equiv 1^{25}\\pmod 5. \\\\ &amp; \\therefore 2^{100} \\pmod 5 \\equiv 1 \\pmod 5. \\end{aligned} ​∵24=16≡1(mod5).∴2100(mod5)=(24)25≡125(mod5).∴2100(mod5)≡1(mod5).​ 附注 AAA与BBB模NNN同余(congruent)，记为A≡B(modN)A \\equiv B \\pmod NA≡B(modN)。 若a≡b(modm)a \\equiv b \\pmod ma≡b(modm)，则aaa的nnn次方与bbb的nnn次方关于模mmm同余，即an≡bn(modm)a^n \\equiv b^n \\pmod man≡bn(modm). \\pmod 是模符号 (mod)\\pmod{}(mod) \\! 是 负间距，可以修正过宽的间距。 \\because 是因为符号 ∵\\because∵ \\therefore 是所以符号 ∴\\therefore∴ \\equiv 是等价于符号 ≡\\equiv≡ 参考链接 The Short Introduction to LaTeX2e (Chinese Simplified)","categories":[],"tags":[]},{"title":"LaTeX练习001","slug":"LaTeX练习001","date":"2024-10-12T03:04:32.000Z","updated":"2024-10-13T14:53:45.027Z","comments":true,"path":"2024/10/12/LaTeX练习001/","link":"","permalink":"http://example.com/2024/10/12/LaTeX%E7%BB%83%E4%B9%A0001/","excerpt":"","text":"问题 证明下列公式： a.∑i=1N(2i−1)=N2 a. \\quad \\displaystyle \\sum\\limits_{i=1}^N {(2i-1)} = N^2 a.i=1∑N​(2i−1)=N2 b.∑i=1Ni3=(∑i=1Ni)2 b. \\quad \\displaystyle \\sum\\limits_{i=1}^N {i^3} = (\\sum\\limits_{i=1}^{N}{i})^2 b.i=1∑N​i3=(i=1∑N​i)2 (a) ∑i=1N(2i−1)=2∑i=1Ni−∑i=1N1=2(1+N)N2−N=N2+N−N=N2\\sum\\limits_{i=1}^N {(2i-1)} = 2\\sum\\limits_{i=1}^N {i} - \\sum\\limits_{i=1}^N {1} = 2\\frac{(1+N)N}{2} - N = N^2 + N - N = N^2 i=1∑N​(2i−1)=2i=1∑N​i−i=1∑N​1=22(1+N)N​−N=N2+N−N=N2 (b) 用数学归纳法(Mathematical Induction)，当N=1N=1N=1时，显然左边等于右边，接着， ∑i=1N+1i3=∑i=1Ni3+(N+1)3=(∑i=1Ni)2+(N+1)3=N2(1+N)24+(N+1)3=(N+1)2(N2+4N+4)4=(N+1)2(N+2)24=(∑i=1N+1i)2\\begin{aligned} \\sum\\limits_{i=1}^{N+1} {i^3} &amp; = \\sum\\limits_{i=1}^{N} {i^3} + (N+1)^3 \\hspace{100cm}\\\\ &amp; = (\\sum\\limits_{i=1}^{N} {i})^2 + (N+1)^3 \\\\ &amp; = \\frac{N^2(1+N)^2}{4} + (N+1)^3 \\\\ &amp; = \\frac{(N+1)^2(N^2+4N+4)}{4} \\\\ &amp; = \\frac{(N+1)^2(N+2)^2}{4} \\\\ &amp; = (\\sum\\limits_{i=1}^{N+1}{i})^2 \\end{aligned} i=1∑N+1​i3​=i=1∑N​i3+(N+1)3=(i=1∑N​i)2+(N+1)3=4N2(1+N)2​+(N+1)3=4(N+1)2(N2+4N+4)​=4(N+1)2(N+2)2​=(i=1∑N+1​i)2​ 附注 \\limits 是让上下标位于上下方。 align 和 aligned 都是对齐公式用的，但align会在每行公式右边 显示 公式编号。 \\hspace&#123;100cm&#125; 是为了靠左对齐公式。 参考链接 The Short Introduction to LaTeX2e (Chinese Simplified)","categories":[],"tags":[]},{"title":"markdown首行缩进","slug":"markdown首行缩进","date":"2024-10-09T13:18:12.000Z","updated":"2024-10-09T13:24:00.797Z","comments":true,"path":"2024/10/09/markdown首行缩进/","link":"","permalink":"http://example.com/2024/10/09/markdown%E9%A6%96%E8%A1%8C%E7%BC%A9%E8%BF%9B/","excerpt":"","text":"背景 写文章的时候遇到了用markdown不知如何首行缩进的问题。记录一下。 解决 &amp;ensp; 半角空格 &amp;emsp; 全角空格 每个转义字符串表示一个空格，首行缩进两个字符&amp;emsp;&amp;emsp;，连续使用两个即可。","categories":[],"tags":[]},{"title":"和群友讨论是否需要看C++ Primer有感","slug":"和群友讨论是否需要看C-Primer有感","date":"2024-10-09T09:37:57.000Z","updated":"2024-10-10T00:48:44.234Z","comments":true,"path":"2024/10/09/和群友讨论是否需要看C-Primer有感/","link":"","permalink":"http://example.com/2024/10/09/%E5%92%8C%E7%BE%A4%E5%8F%8B%E8%AE%A8%E8%AE%BA%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E7%9C%8BC-Primer%E6%9C%89%E6%84%9F/","excerpt":"","text":"起因 一个新手群友在群里突然发了一张图片，说图片里书上的代码 #include &quot;Sales_item.h&quot;报错，书中并没有写这个文件。我一眼看出了是该书是C++ Primer，知道书中有过介绍一个链接，点击链接就能够获取到一些文件，这些文件就包含Sales_item.h。于是回翻了一下该书，找到了链接，在浏览器网址输入发现好像失效了，没能找到文件，群里另一个人也试了，结果也说失效了。我于是翻了我的文件夹，找到了以前下载的文件压缩包，发给了群友。 经过 好了，本来事情到上面已经完美解决，结束了。但刚说链接失效的那个人说“C++ Primer又厚又无聊”。 这时又有一个群友冒了出来说“如果不是闲的无聊，建议不要看这书，没啥好看的…有空多写写项目”，这句话后半句是对的，前半句有待商榷… 诸如此类还有： “有空写书上的例题，不如去洛谷做几个题” “过语法还不如去菜鸟上看” “我是说找本薄点比较新的的书过一遍就差不多了()” 等等 回应 “不包括其他OJ平台，目前在洛谷做了400+题了” “我好久以前试过菜鸟，后来还是看书了” “我目前觉得看完C++ Primer的较大收获之一是，在C++11的语法和诸多特性层面不用盲目网上搜索答案，要么自己已经牢记于心，要么会在脑海留下印记，稍微回翻一下书就能很快找到出处（可靠性高）” “当然我知道看完这本书才仅仅只是个开始，但能够进入一个新的阶段，不用【经常性地】在基础问题上还需要盲目网上搜索或者问人” 后期 现在没人说该不该看C++ Primer了，我就当是我说服了大家（bushi。 突然有个人问：“这本书你看了多久看完？” 我说：“我觉得不要纠结于看多久，边看边写书上的代码，养成一种沉浸感，即使我早已看完敲完书上包括练习的代码，就刚刚也仍然把书又拿起来翻网址。看的过程会反复回看，看完也会在后面的应用中不断地回翻，但这个回翻过程会越来越快，甚至我想到了将来某个时候我都完全不用回翻了（幻想），那个时候想必C++水平和现在水平会有质的不同吧” 最后有群友认可了我说的，“就是反复”。 结语 最重要的东西往往是最简单的，需要把各门学科的基本概念搞清楚，能融会贯通、举一反三，大部分难题都会迎刃而解了。","categories":[],"tags":[]},{"title":"洛谷P5949","slug":"洛谷P5949","date":"2024-10-04T02:59:55.000Z","updated":"2024-10-04T10:18:57.516Z","comments":true,"path":"2024/10/04/洛谷P5949/","link":"","permalink":"http://example.com/2024/10/04/%E6%B4%9B%E8%B0%B7P5949/","excerpt":"","text":"[BalticOI 2000] Division expression 洛谷P5949 题目描述 除法表达式有如下的形式: X1/X2/X3.../XnX_1/X_2/X_3.../X_nX1​/X2​/X3​.../Xn​ ，其中 XiX_iXi​ 是正整数且 Xi≤109X_i\\le 10^9Xi​≤109， 除法表达式应当按照从左到右的顺序求。 例如表达式 1/2/1/21/2/1/21/2/1/2的值为 1/41/41/4。 但可以在表达式中加入括号来改变计算顺序，例如 (1/2)/(1/2)(1/2)/(1/2)(1/2)/(1/2) 的值为 111.现给出一个除法表达式 EEE，求是告诉是否可以通过增加括号来使其结果为整数。 输入格式 第一行一个整数 DDD，代表有 DDD 组数据。 每组数据先给出一个数字 NNN，代表这组数据将有 NNN 个数。 接下来每行有 NNN 个数。 输出格式 如果能使得表达式的值为一个整数，则输出 YES ，否则为NO。 样例 #1 样例输入 #1 123456789102412123123 样例输出 #1 12YESNO 提示 对于 100%100\\%100% 的数据，1≤D≤101\\le D\\le101≤D≤10，1≤n≤1041\\le n\\le10^41≤n≤104。 解法1 高精度解法（但TLE） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114// P5949 TLE!!!// 法1// #define LOCAL#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int maxn = 10000;int X[maxn];// 输入为逆序存储的数，输出也是逆序存储// 高精度乘法vector&lt;int&gt; mul(const vector&lt;int&gt; &amp;a, const vector&lt;int&gt; &amp;b)&#123; int lena = a.size(); int lenb = b.size(); vector&lt;int&gt; c(lena + lenb); for (int i = 0; i &lt; lena; ++i) for (int j = 0; j &lt; lenb; ++j) &#123; c[i + j] += a[i] * b[j]; c[i + j + 1] += c[i + j] / 10; c[i + j] %= 10; &#125; while (c.size() &gt; 1 &amp;&amp; c.back() == 0) c.pop_back(); return c;&#125;// 输入为逆序存储的数，若能整除，返回true，否则返回false// 高精度整数除法bool div(const vector&lt;int&gt; &amp;a, int b)&#123; int lena = a.size(); vector&lt;int&gt; c(lena); int t = 0; // 因为输入为逆序存储，所以从后往前遍历 for (int i = lena - 1; i &gt;= 0; --i) &#123; t = t * 10 + a[i]; c[i] = t / b; t %= b; &#125; // 因为本题只需要判断是否能整除，所以只返回一个bool值 if (t) return false; else return true;&#125;// 输入一个整数，返回其逆序存储的数组vector&lt;int&gt; int_to_vector(int x)&#123; vector&lt;int&gt; ans; while (x) &#123; ans.push_back(x % 10); x /= 10; &#125; return ans.empty() ? vector&lt;int&gt;(1, 0) : ans;&#125;int main()&#123;#ifdef LOCAL freopen(&quot;page_311_data.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;page_311.out&quot;, &quot;w&quot;, stdout);#endif int t, n; cin &gt;&gt; t; while (t--) &#123; cin &gt;&gt; n; for (int i = 0; i &lt; n; ++i) cin &gt;&gt; X[i]; // 1个数直接判断 if (n == 1) &#123; cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; continue; &#125; vector&lt;int&gt; a = int_to_vector(X[0]); int b = X[1]; bool is_zero = false; for (int i = 2; i &lt; n; ++i) &#123; is_zero = div(a, b); if (is_zero) break; a = mul(a, int_to_vector(X[i])); &#125; // 判断最后一个 is_zero = div(a, b); if (is_zero) cout &lt;&lt; &quot;YES\\n&quot;; else cout &lt;&lt; &quot;NO\\n&quot;; &#125; return 0;&#125; 解法2 唯一分解定理解法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107// 唯一分解定理解法！AC!// #define LOCAL#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;const int maxn = 10000;int a[maxn];vector&lt;int&gt; primes;const int maxp = 1000000;int vis[maxp + 1];// 预处理// Eratosthenes 筛法 生成 2到maxp的 素数表// 素数表为全局变量 primesvoid pre()&#123; int m = sqrt(maxp + 0.5); for (int i = 2; i &lt;= m; ++i) if (!vis[i]) for (int j = i * i; j &lt;= maxp; j += i) vis[j] = 1; for (int i = 2; i &lt;= maxp; ++i) if (!vis[i]) primes.push_back(i);&#125;// 唯一分解定理// 给定正整数n的唯一分解式 n = p1^e1 * p2^e2 * ... * pk^ek// m的 第一维是因数（约数divisor)，第二维是次幂// 最后n的正约数个数为：// (e1 + 1) * (e2 + 1) * ... * (ek + 1)map&lt;int, int&gt; m;// 输入正整数n，求出它的因数分解，存在map中void solve(int n)&#123; for (const auto &amp;p : primes) &#123; if (p * p &gt; n) break; while (n % p == 0) &#123; ++m[p]; n /= p; &#125; &#125; if (n != 1) ++m[n];&#125;int main()&#123;#ifdef LOCAL freopen(&quot;page_311_data.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;page_311.out&quot;, &quot;w&quot;, stdout);#endif pre(); int T; cin &gt;&gt; T; while (T--) &#123; // m必须初始化，清空 m.clear(); int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; ++i) cin &gt;&gt; a[i]; // 第二个数 solve(a[1]); map&lt;int, int&gt; tmp = m; m.clear(); solve(a[0]); for (int i = 2; i &lt; n; ++i) solve(a[i]); bool flag = true; // 遍历tmp所有的约数 for (const auto &amp;[key, val] : tmp) &#123; // 如果m中没有key，或者key存在但是次数小于tmp[key] if (!m.count(key) || (m.count(key) &amp;&amp; m[key] &lt; val)) &#123; // 不能整除 flag = false; break; &#125; &#125; if (flag) cout &lt;&lt; &quot;YES\\n&quot;; else cout &lt;&lt; &quot;NO\\n&quot;; &#125; return 0;&#125; 解法3 gcd(greatest common divisor)解法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// AC!!!// #define LOCAL#include &lt;iostream&gt;using namespace std;const int maxn = 10001;int X[maxn];int n;// 欧几里得算法（Euclid algorithm）// 又叫 辗转相除法// 求 最大公约数（Greatest Common Divisor）int gcd(int a, int b)&#123; if (b == 0) return a; return gcd(b, a % b);&#125;// 判断能否整除bool judge()&#123; X[2] /= gcd(X[2], X[1]); for (int i = 3; i &lt;= n; ++i) X[2] /= gcd(X[2], X[i]); return X[2] == 1;&#125;int main()&#123;#ifdef LOCAL freopen(&quot;page_311_data.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;page_311.out&quot;, &quot;w&quot;, stdout);#endif int t; cin &gt;&gt; t; while (t--) &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; X[i]; if (judge()) cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; &#125; return 0;&#125;","categories":[],"tags":[]},{"title":"Visual Studio 2022","slug":"Visual-Studio-2022","date":"2024-10-03T09:48:06.000Z","updated":"2024-10-03T13:27:37.641Z","comments":true,"path":"2024/10/03/Visual-Studio-2022/","link":"","permalink":"http://example.com/2024/10/03/Visual-Studio-2022/","excerpt":"","text":"安装Visual Studio Community 2022 下载地址 https://appzip.cn/vs2022/w 选择社区版下载 在 工作负荷 中勾选 使用 C++ 的桌面开发 在 语言包 中勾选 自己习惯的语言，如 中文(简体) 在 安装位置 中修改安装位置，例如： Visual Studio IDE: D:\\Program Files\\Microsoft Visual Studio\\2022\\Community 下载缓存: D:\\ProgramData\\Microsoft\\VisualStudio\\Packages 勾选“安装完成后保留下载缓存”，方便以后更新组件 共享组建、工具和 SDK: D:\\Program Files (x86)\\Microsoft Visual Studio\\Shared 最后点击 安装 即可。 初次设置 开发设置选择 Visual C++ (如果点成常规就到 工具 -&gt; 导入和导出设置 -&gt; 重置所有设置 -&gt; 是，保留我的当前设置 里改) 颜色主题选择 深色 Visual C++ 入门 在 Visual Studio 中安装 C 和 C++ 支持 创建 C++ 控制台应用项目 生成并运行 C++ 控制台应用项目 用 C++ 创建控制台计算器 设置vscode Consolas 同款字体 工具 -&gt; 选项 -&gt; 环境 -&gt; 字体和颜色 显示其设置 选择 文本编辑器 字体 选择 Consolas 确定 设置vscode Dark+ 同款主题 法一 扩展 -&gt; 管理扩展 -&gt; 搜索Visual Studio Theme Pack -&gt; 安装扩展极慢（近似没有） 法二 访问Visual Studio 插件市场 选择或搜索 Visual Studio Theme Pack 点击 Download，下载文件名为 VisualStudioThemePack.vsix 双击 VisualStudioThemePack.vsix 文件，安装插件 安装完成后，启动 Visual Studio 便可使用。 启动 Visual Studio 后 工具 -&gt; 主题 -&gt; Dark+","categories":[],"tags":[]},{"title":"C++生成无开发环境依赖的exe文件","slug":"C-生成无开发环境依赖的exe文件","date":"2024-09-24T09:38:00.000Z","updated":"2024-09-24T09:56:22.880Z","comments":true,"path":"2024/09/24/C-生成无开发环境依赖的exe文件/","link":"","permalink":"http://example.com/2024/09/24/C-%E7%94%9F%E6%88%90%E6%97%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%BE%9D%E8%B5%96%E7%9A%84exe%E6%96%87%E4%BB%B6/","excerpt":"","text":"安装Visual C++ 2010 详细步骤参考https://codebus.cn/yangw/setup-vc2010 注意 visual c++ 2010 不支持C++11 创建、管理及发布项目 详细步骤参考https://codebus.cn/zhaoh/create-and-manage-projects-with-vc","categories":[],"tags":[]},{"title":"github加速","slug":"github加速","date":"2024-09-22T00:51:53.000Z","updated":"2024-09-22T01:43:56.329Z","comments":true,"path":"2024/09/22/github加速/","link":"","permalink":"http://example.com/2024/09/22/github%E5%8A%A0%E9%80%9F/","excerpt":"","text":"问题描述 无法访问github hexo d报错 1234567fatal: unable to access &#x27;https://github.com/WangShiSuiFeng24/WangShiSuiFeng24.github.io.git/&#x27;: Failed to connect to github.com port 443 after 21101 ms: Couldn&#x27;t connect to serverFATAL Something&#x27;s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.html : Couldn&#x27;t connect to serverError: Spawn failed at ChildProcess.&lt;anonymous&gt; (C:\\Users\\mingandong\\blog\\node_modules\\hexo-util\\lib\\spawn.js:51:21) at ChildProcess.emit (node:events:514:28) at cp.emit (C:\\Users\\mingandong\\blog\\node_modules\\cross-spawn\\lib\\enoent.js:34:29) at ChildProcess._handle.onexit (node:internal/child_process:291:12) 解决方法 访问https://www.ipaddress.com/website/github.com/获取github.com的ip地址 将ip地址添加到hosts文件中 windows下hosts文件的路径为: C:\\Windows\\System32\\drivers\\etc\\ 需要管理员权限 eg: 140.82.113.4 github.com 保存 原理 绕过dns解析，在本地直接绑定host，该方法也可加速其他因为CDN被屏蔽导致访问慢的网站。","categories":[],"tags":[]},{"title":"指派问题","slug":"指派问题","date":"2024-09-21T09:08:10.000Z","updated":"2024-09-22T02:17:18.674Z","comments":true,"path":"2024/09/21/指派问题/","link":"","permalink":"http://example.com/2024/09/21/%E6%8C%87%E6%B4%BE%E9%97%AE%E9%A2%98/","excerpt":"","text":"问题描述 描述 分配工作 甲、乙、丙、丁4人都能完成A、B、C、D4项工作，但是甲、乙、丙、丁4人做这4项工作的价值不同。给甲、乙、丙、丁分配工作时，每人能且仅能分配一项工作，每项工作有且仅有一人做，如何分配工作，才能使总价值最大。 工作价值表： A B C D 甲 4 4 1 3 乙 8 5 4 6 丙 4 3 9 5 丁 6 2 8 1 最大总价值25 人数和工作数都是n时，如何给n人分配n项工作，才能使n人完成n项工作的总价值最大 输入 n+1行，第1行是正整数n（小于10），第2到第n+1行是n个人的工作价值表。 输出 输出一个整数，表示最大总价值。 样例输入 1234549 3 3 82 7 5 97 5 9 59 7 6 8 样例输出 134 原题链接 http://gxdd.openjudge.cn/code18/1155/ 解题思路 排列解法 排列解法主要思路 可将此类问题视为排列问题，从 {0,1,...,n−1}\\{0, 1, ... , n-1\\}{0,1,...,n−1} 开始，枚举所有排列，下标表示行，对应值表示列 时间复杂度（排列） O(n!)O(n!)O(n!) 代码（排列解法） 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; vector&lt;vector&lt;int&gt;&gt; a; int n; scanf(&quot;%d&quot;, &amp;n); vector&lt;int&gt; tmp; int x; for (int r = 0; r &lt; n; ++r) &#123; tmp.clear(); for (int c = 0; c &lt; n; ++c) &#123; scanf(&quot;%d&quot;, &amp;x); tmp.push_back(x); &#125; a.push_back(tmp); &#125; vector&lt;int&gt; cols(n); for (int c = 0; c &lt; n; ++c) cols[c] = c; int max_sum = 0; do &#123; int sum = 0; for (int row = 0; row &lt; n; ++row) &#123; int col = cols[row]; sum += a[row][col]; &#125; if (sum &gt; max_sum) max_sum = sum; &#125; while (next_permutation(cols.begin(), cols.end())); printf(&quot;%d\\n&quot;, max_sum); return 0;&#125; 匈牙利算法（Hungarian algorithm） 输入格式要求 第一行 矩阵行列大小n（要求行列必须相等） 第二到n+1行 行列均为n的矩阵（要求元素值为正整数） 输出 一个整数，表示最大值（适当修改可输出最小值） 匈牙利算法主要思路 通过不同形式的加法或减法，变换拷贝后的矩阵，变换后矩阵 不影响最终位置的选择，也就不影响最终的最值。 时间复杂度（匈牙利） O(n2)O(n^2)O(n2) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312#include &lt;cstdio&gt;#include &lt;climits&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;algorithm&gt;using namespace std;// 输入数据int n;vector&lt;vector&lt;int&gt;&gt; a;// tmp是矩阵a的拷贝，匈牙利算法变换的矩阵为该矩阵vector&lt;vector&lt;int&gt;&gt; tmp;// row_set, col_set 分别存储行和列的被划线集合set&lt;int&gt; row_set, col_set;// 输出// ans_set 存储最终选择的位置集合set&lt;pair&lt;int, int&gt;&gt; ans_set;void pre_process();void step_1();void step_2();void step_3();int main()&#123; // 输入 scanf(&quot;%d&quot;, &amp;n); int val; vector&lt;int&gt; tmp_row; for (int r = 0; r &lt; n; ++r) &#123; tmp_row.clear(); for (int c = 0; c &lt; n; ++c) scanf(&quot;%d&quot;, &amp;val), tmp_row.push_back(val); a.push_back(tmp_row); &#125; // 拷贝矩阵a，匈牙利算法变换的矩阵为tmp tmp = a; pre_process(); step_1(); // 循环 直到行和列的划线集合个数之和 &gt;= n while (1) &#123; step_2(); if (row_set.size() + col_set.size() &gt;= n) break; step_3(); &#125; // 准备输出 row_set.clear(); col_set.clear(); ans_set.clear(); // step_2 会顺便将 ans_set 填充 step_2(); // 将选择的位置处的值相加 int ans = 0; for (const auto &amp;p : ans_set) ans += a[p.first][p.second]; // 输出 printf(&quot;%d\\n&quot;, ans); return 0;&#125;// 预处理// 【匈牙利算法 本来是求最小值的】// 将拷贝后的矩阵tmp 每个元素 取相反数// 取反相反数后的tmp 每个元素 减去 tmp所有元素中的最小值, 使得元素值都 &gt;=0// 则【将 求最大值 转化为 求最小值】// 若 题目 求最小值，可跳过 此步骤void pre_process()&#123; int min_val = 0; // 对矩阵tmp 每个元素取相反数，同时 找到矩阵tmp 中最小值 for (int r = 0; r &lt; n; ++r) for (int c = 0; c &lt; n; ++c) &#123; tmp[r][c] = -a[r][c]; if (tmp[r][c] &lt; min_val) min_val = tmp[r][c]; &#125; // 矩阵tmp 每个元素减去 最小值，使得元素值都 &gt;=0 for (int r = 0; r &lt; n; ++r) for (int c = 0; c &lt; n; ++c) tmp[r][c] -= min_val;&#125;// 【第一步，依次减去行和列的最小值】void step_1()&#123; // row_min, col_min 分别存储每行和每列的最小值 vector&lt;int&gt; row_min(n), col_min(n); for (int r = 0; r &lt; n; ++r) row_min[r] = *min_element(tmp[r].begin(), tmp[r].end()); // 每行减去 行中最小值 for (int r = 0; r &lt; n; ++r) for (int c = 0; c &lt; n; ++c) tmp[r][c] -= row_min[r]; for (int c = 0; c &lt; n; ++c) &#123; col_min[c] = tmp[0][c]; for (int r = 1; r &lt; n; ++r) col_min[c] = min(col_min[c], tmp[r][c]); &#125; // 每列减去 列中最小值 for (int r = 0; r &lt; n; ++r) for (int c = 0; c &lt; n; ++c) &#123; tmp[r][c] -= col_min[c]; &#125;&#125;// 【第二步，行有独立划掉列，列有独立划掉行】// 这里的独立是指 有且仅有一个0// 划掉的行列分别 放入 row_set 和 col_set// 被划掉的0不计数// 【补丁】// 若仍有0元素，且同行（列）的0元素至少有2个。// 从剩余0元素最少的行开始，比较该行0元素所在列中0的数目，选择0元素较少的那列的这个0元素加圈（选出该位置），然后将该行（列）划线。// 反复 此过程，直到所有0元素都被圈出（选择该位置）或划掉。void step_2()&#123; row_set.clear(); col_set.clear(); // 循环 直到没有0元素 while (1) &#123; // 若没有0元素，跳出循环 // 若有0元素，但所有0元素都被划掉或圈出（选位置），跳出循环 bool has_zero = false; for (int r = 0; r &lt; n; ++r) &#123; if (row_set.count(r)) continue; for (int c = 0; c &lt; n; ++c) if (!col_set.count(c) &amp;&amp; tmp[r][c] == 0) has_zero = true; &#125; if (!has_zero) break; // 循环 直到没有独立的行或列 while (1) &#123; bool has_independent_zero = false; // 行有独立划掉列 // 被划掉的0不计数 for (int r = 0; r &lt; n; ++r) &#123; if (row_set.count(r)) continue; int cnt = 0; int tmp_c; for (int c = 0; c &lt; n; ++c) &#123; if (!col_set.count(c) &amp;&amp; tmp[r][c] == 0) ++cnt, tmp_c = c; if (cnt &gt; 1) break; &#125; if (cnt == 1) &#123; col_set.insert(tmp_c), has_independent_zero = true; // 顺便将 ans_set 填充 ans_set.insert(&#123;r, tmp_c&#125;); &#125; &#125; // 列有独立划掉行 // 被划掉的0不计数 for (int c = 0; c &lt; n; ++c) &#123; if (col_set.count(c)) continue; int cnt = 0; int tmp_r; for (int r = 0; r &lt; n; ++r) &#123; if (!row_set.count(r) &amp;&amp; tmp[r][c] == 0) ++cnt, tmp_r = r; if (cnt &gt; 1) break; &#125; if (cnt == 1) &#123; row_set.insert(tmp_r), has_independent_zero = true; // 顺便将 ans_set 填充 ans_set.insert(&#123;tmp_r, c&#125;); &#125; &#125; // 没有独立的行或列，跳出循环 if (!has_independent_zero) break; &#125; // 若仍有0元素，且同行（列）的0元素至少有2个。 // 从剩余0元素最少的行开始，比较该行0元素所在列中0的数目，选择0元素较少的那列的这个0元素加圈（选出该位置），然后将该行（列）划线。 // 反复 此过程，直到所有0元素都被圈出（选择该位置）或划掉。 while (1) &#123; // min_zero_row 存储 行中0元素最少的行号 // min_zero_cnt 存储 所有行最小的0元素个数 int min_zero_row = -1, min_zero_cnt = INT_MAX; // col_index_of_min_row_zero 存储 0元素最少行 的0元素所在的列号 vector&lt;int&gt; col_index_of_min_row_zero; // col_index_of_cur_row_zero 存储 当前行中0元素所在的列号 vector&lt;int&gt; col_index_of_cur_row_zero; // 找到 行中0元素最少的行号 和 0元素最少的行中0元素所在的列号 for (int r = 0; r &lt; n; ++r) &#123; if (row_set.count(r)) continue; int cnt = 0; col_index_of_cur_row_zero.clear(); for (int c = 0; c &lt; n; ++c) &#123; if (!col_set.count(c) &amp;&amp; tmp[r][c] == 0) &#123; ++cnt; col_index_of_cur_row_zero.push_back(c); &#125; &#125; if (cnt &gt;= 2 &amp;&amp; cnt &lt; min_zero_cnt) &#123; min_zero_row = r; min_zero_cnt = cnt; col_index_of_min_row_zero = col_index_of_cur_row_zero; &#125; &#125; // 没有0元素，跳出循环 if (min_zero_row == -1) break; // min_zero_col 存储 0元素最少列号 int min_zero_col = -1; // min_zero_cnt 存储 0元素最少列中0元素个数 min_zero_cnt = INT_MAX; // col_index_of_cur_row_zero中 找到0元素最少的列 for (const auto &amp;c : col_index_of_min_row_zero) &#123; int cnt = 0; for (int r = 0; r &lt; n; ++r) if (!row_set.count(r) &amp;&amp; tmp[r][c] == 0) ++cnt; if (cnt &lt; min_zero_cnt) &#123; min_zero_cnt = cnt; min_zero_col = c; &#125; &#125; // 划掉行和列 row_set.insert(min_zero_row); col_set.insert(min_zero_col); // 顺便将 ans_set 填充（圈出） ans_set.insert(&#123;min_zero_row, min_zero_col&#125;); &#125; &#125;&#125;// 【第三步，把剩下部分的数字减去其中的min，对划线交叉的数字加上min】void step_3()&#123; int min_value = INT_MAX; // 找到所有未划掉的数字的最小值 for (int r = 0; r &lt; n; ++r) for (int c = 0; c &lt; n; ++c) &#123; if (!row_set.count(r) &amp;&amp; !col_set.count(c) &amp;&amp; tmp[r][c] &lt; min_value) min_value = tmp[r][c]; &#125; // 减去最小值，加上最小值 for (int r = 0; r &lt; n; ++r) for (int c = 0; c &lt; n; ++c) &#123; if (!row_set.count(r) &amp;&amp; !col_set.count(c)) tmp[r][c] -= min_value; if (row_set.count(r) &amp;&amp; col_set.count(c)) tmp[r][c] += min_value; &#125;&#125; 参考链接 一个匈牙利算法网站 匈牙利算法视频讲解1 匈牙利算法视频讲解2 匈牙利算法视频讲解3 匈牙利算法文章讲解1","categories":[],"tags":[]},{"title":"P1990 覆盖墙壁","slug":"P1990-覆盖墙壁","date":"2024-09-07T02:39:08.000Z","updated":"2024-09-07T03:05:59.157Z","comments":true,"path":"2024/09/07/P1990-覆盖墙壁/","link":"","permalink":"http://example.com/2024/09/07/P1990-%E8%A6%86%E7%9B%96%E5%A2%99%E5%A3%81/","excerpt":"","text":"题目 洛谷P1990 覆盖墙壁 思路1 b站涂老师的视频 核心递推方程： f(n)=f(n−1)+f(n−2)+2g(n−1)g(n)=f(n−2)+g(n−1)f(n) = f(n-1) + f(n-2) + 2g(n-1)\\\\ g(n) = f(n-2) + g(n-1) f(n)=f(n−1)+f(n−2)+2g(n−1)g(n)=f(n−2)+g(n−1) 思路2 洛谷某网友玄学题解 核心递推方程： f(n)=2f(n−1)+f(n−3)f(n) = 2f(n-1) + f(n-3) f(n)=2f(n−1)+f(n−3) 思路1到思路2方程的推导过程 思路1第一个方程 f(n)=f(n−1)+f(n−2)+2g(n−1)f(n) = f(n-1) + f(n-2) + 2g(n-1) f(n)=f(n−1)+f(n−2)+2g(n−1) 将 n−1n-1n−1 带入上式 f(n−1)=f(n−2)+f(n−3)+2g(n−2)f(n-1) = f(n-2) + f(n-3) + 2g(n-2) f(n−1)=f(n−2)+f(n−3)+2g(n−2) 将上面第一个式子减第二个式子 f(n)−f(n−1)=f(n−1)−f(n−3)+2(g(n−1)−g(n−2))f(n) - f(n-1) = f(n-1) - f(n-3) + 2(g(n-1) - g(n-2)) f(n)−f(n−1)=f(n−1)−f(n−3)+2(g(n−1)−g(n−2)) 将 n−1n-1n−1 带入思路1的第二个方程 g(n−1)=f(n−3)+g(n−2)⇒g(n−1)−g(n−2)=f(n−3)g(n-1) = f(n-3) + g(n-2) \\\\ \\Rightarrow g(n-1) - g(n-2) = f(n-3) g(n−1)=f(n−3)+g(n−2)⇒g(n−1)−g(n−2)=f(n−3) 所以经推导可得思路2的方程 f(n)−f(n−1)=f(n−1)−f(n−3)+2f(n−3)⇒f(n)=2f(n−1)+f(n−3)f(n) - f(n-1) = f(n-1) - f(n-3) + 2f(n-3) \\\\ \\Rightarrow f(n) = 2f(n-1) + f(n-3) f(n)−f(n−1)=f(n−1)−f(n−3)+2f(n−3)⇒f(n)=2f(n−1)+f(n−3)","categories":[],"tags":[]},{"title":"让hexo支持latex数学公式","slug":"让hexo支持latex数学公式","date":"2024-09-05T10:40:39.000Z","updated":"2024-09-05T10:55:28.752Z","comments":true,"path":"2024/09/05/让hexo支持latex数学公式/","link":"","permalink":"http://example.com/2024/09/05/%E8%AE%A9hexo%E6%94%AF%E6%8C%81latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/","excerpt":"","text":"流程 卸载原来的渲染器 1npm un hexo-renderer-marked 安装新的渲染器 1npm i hexo-renderer-markdown-it-katex 修改配置文件, 在_config.yml文件末尾添加如下内容 1234567891011markdown: render: html: true xhtmlOut: false breaks: true linkify: true typographer: true plugins: anchors: level: 1 collisionSuffix: &#x27;&#x27; 参考链接 https://nickxu.me/2022/04/17/Hexo-Butterfly-建站指南（八）使用-KaTeX-数学公式/","categories":[],"tags":[]},{"title":"卡特兰数","slug":"卡特兰数","date":"2024-09-05T01:25:18.000Z","updated":"2024-09-05T10:37:50.316Z","comments":true,"path":"2024/09/05/卡特兰数/","link":"","permalink":"http://example.com/2024/09/05/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/","excerpt":"","text":"基本简介 卡特兰数（英文名：Catalan number）又称卡塔兰数，是组合数学中一个常出现在各种计数问题中的数列。 卡特兰数的首创者是中国清代数学家明安图。 通项公式，递推关系 (1)Hn=C2nn−C2nn−1(1) \\quad H_n = C_{2n}^{n} - C_{2n}^{n-1}(1)Hn​=C2nn​−C2nn−1​ (2)Hn=1n+1C2nn(2) \\quad H_n = \\frac{1}{n+1}C_{2n}^{n}(2)Hn​=n+11​C2nn​ (3)Hn=4n−2n+1Hn−1(3) \\quad H_n = \\frac{4n-2}{n+1}H_{n-1}(3)Hn​=n+14n−2​Hn−1​ 数列前n项 H0H_0H0​ H1H_1H1​ H2H_2H2​ H3H_3H3​ H4H_4H4​ H5H_5H5​ H6H_6H6​ H7H_7H7​ H8H_8H8​ H9H_9H9​ 1 1 2 5 14 42 132 429 1430 4862 H10H_{10}H10​ H11H_{11}H11​ H12H_{12}H12​ H13H_{13}H13​ H14H_{14}H14​ H15H_{15}H15​ H16H_{16}H16​ H17H_{17}H17​ H18H_{18}H18​ H19H_{19}H19​ 16796 58786 208012 742900 2674440 9694845 35357670 129644790 477638700 1767263190 应用 n个节点构造二叉树问题 出栈序列问题 括号匹配问题","categories":[],"tags":[]},{"title":"快速排序","slug":"快速排序","date":"2024-08-20T09:12:53.000Z","updated":"2024-10-08T13:00:18.248Z","comments":true,"path":"2024/08/20/快速排序/","link":"","permalink":"http://example.com/2024/08/20/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","excerpt":"","text":"快速排序 快速排序是一种分治算法，其基本思想是：通过一趟排序将待排序记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。 题目 洛谷P1177 版本1 部分测试点超时，本地跑第5个测试点，递归深度过深导致 segmentation fault 可在排序前用 is_sorted 判断是否已经有序，若有序则直接输出，否则继续排序 12345678910111213141516171819202122void quick_sort(int *a, int left, int right)&#123; if (left &gt;= right) return; int base = a[left]; int i = left, j = right; while (i &lt; j) &#123; while (i &lt; j &amp;&amp; a[j] &gt;= base) --j; a[j] = a[i]; while (i &lt; j &amp;&amp; a[i] &lt;= base) ++i; a[i] = a[j]; &#125; a[i] = base; quick_sort(a, left, i - 1); quick_sort(a, i + 1, right);&#125; 版本2 AC版本 123456789101112131415161718192021222324void quick_sort(int *a, int left, int right)&#123; if (left &gt;= right) return; int i = left - 1, j = right + 1; int x = a[left + right &gt;&gt; 1]; while (i &lt; j) &#123; do ++i; while (a[i] &lt; x); do --j; while (a[j] &gt; x); if (i &lt; j) swap(a[i], a[j]); &#125; quick_sort(a, left, j); quick_sort(a, j + 1, right);&#125; 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void quick_sort(int *a, int left, int right)&#123; if (left &gt;= right) return; int i = left - 1, j = right + 1; int x = a[left + right &gt;&gt; 1]; while (i &lt; j) &#123; do ++i; while (a[i] &lt; x); do --j; while (a[j] &gt; x); if (i &lt; j) swap(a[i], a[j]); &#125; quick_sort(a, left, j); quick_sort(a, j + 1, right);&#125;int main()&#123; int n; cin &gt;&gt; n; vector&lt;int&gt; a(n); for (int i = 0; i &lt; n; ++i) cin &gt;&gt; a[i]; quick_sort(&amp;a[0], 0, n - 1); for (int i = 0; i &lt; n; ++i) cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; return 0;&#125;","categories":[],"tags":[]},{"title":"hexo d时产生的bug","slug":"hexo-d时产生的bug","date":"2024-06-21T05:25:18.000Z","updated":"2024-06-21T05:58:19.053Z","comments":true,"path":"2024/06/21/hexo-d时产生的bug/","link":"","permalink":"http://example.com/2024/06/21/hexo-d%E6%97%B6%E4%BA%A7%E7%94%9F%E7%9A%84bug/","excerpt":"","text":"bug信息 123456789101112131415161718192021222324INFO Validating configINFO =================================================================== ##### # # ##### ##### ###### ##### ###### # # # # # # # # # # # # # # # # ##### # # # # ##### # # ##### # # # # # # # # # ##### # # # # # # # # # # # # # # # ##### #### # # ###### # # # ###### # 4.9.0 ===================================================================INFO Deploying: gitINFO Clearing .deploy_git folder...INFO Copying files from public folder...INFO Copying files from extend dirs...On branch masternothing to commit, working tree cleanfatal: unable to access &#x27;https://github.com/WangShiSuiFeng24/WangShiSuiFeng24.github.io.git/&#x27;: SSL certificate problem: unable tole to get local issuer certificateFATAL Something&#x27;s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.htmlError: Spawn failed at ChildProcess.&lt;anonymous&gt; (C:\\Users\\mingandong\\blog\\node_modules\\hexo-util\\lib\\spawn.js:51:21) at ChildProcess.emit (node:events:514:28) at cp.emit (C:\\Users\\mingandong\\blog\\node_modules\\cross-spawn\\lib\\enoent.js:34:29) at ChildProcess._handle.onexit (node:internal/child_process:291:12) 解决方法 这个问题是由于一些问题导致无法访问 GitHub。具体来说，错误信息显示 SSL 证书的问题，无法获取本地发行者证书。 解决此问题的一种可能方法是将 Git 配置更改为允许不验证 SSL 证书。可以使用以下命令来更改 Git 的全局配置： 1git config --global http.sslVerify false 然后再次尝试执行操作(hexo d)，看是否能够成功访问 GitHub 仓库。 这里已经能解决问题了，但是，如果还不行，可以尝试以下方法 可以尝试更新 Git 的证书存储。这可以通过以下步骤完成：下载最新的证书存储文件：https://curl.haxx.se/ca/cacert.pem。 将证书存储文件保存到你的电脑上的某个目录中，比如 C:\\。 打开 Git Bash 或命令提示符，并运行以下命令： 1git config --global http.sslCAInfo C:/cacert.pem 确保将路径 C:/cacert.pem 替换为实际保存证书存储文件的路径。这些方法应该能够解决问题。如果问题仍然存在，参考 Hexo 文档中的故障排除指南，可能会提供更多有关此错误的解决方案。","categories":[],"tags":[]},{"title":"谷歌翻译问题解决方案","slug":"谷歌翻译问题解决方案","date":"2024-06-21T04:22:59.000Z","updated":"2024-06-21T04:57:42.931Z","comments":true,"path":"2024/06/21/谷歌翻译问题解决方案/","link":"","permalink":"http://example.com/2024/06/21/%E8%B0%B7%E6%AD%8C%E7%BF%BB%E8%AF%91%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"","text":"装插件 浏览器扩展程序中装 Google翻译 插件 登录github，找工具 使用 steam++(已改名为Watt Toolkit) 加速访问 github https://steampp.net/ 搜索栏搜索 GoogleTranslate_IPFinder https://github.com/GoodCoder666/GoogleTranslate_IPFinder 点击稳定版下载地址， 若下载缓慢或无法下载，您可以通过 GitHub Proxy 代理加速下载 https://github.com/GoodCoder666/GoogleTranslate_IPFinder/releases 运行工具 工具名：checker-win-x64.exe。 右键-&gt;以管理员身份运行， 点击“测速”，等待操作完成， 点击“写入Hosts”，谷歌翻译API即可正常使用。 此时，网页中 右键-&gt;翻译成中文(简体) 可正常使用。 另外 管理身份打开hosts文件。 C:\\Windows\\System32\\drivers\\etc&gt;notepad hosts 在前面生成的相同ip下，添加translate.google.com 例(前两个由工具生成，最后一个手动添加)： 216.239.32.40 translate.googleapis.com 216.239.32.40 translate-pa.googleapis.com 216.239.32.40 translate.google.com 保存。 如此可实现 选中-&gt;右键-&gt;谷歌翻译。 还可直接访问谷歌翻译网页。 https://translate.google.com","categories":[],"tags":[]},{"title":"bilibili视频解析下载+字幕+压缩","slug":"bilibili视频解析下载-字幕-压缩","date":"2023-11-24T00:33:09.000Z","updated":"2023-11-24T00:55:39.706Z","comments":true,"path":"2023/11/24/bilibili视频解析下载-字幕-压缩/","link":"","permalink":"http://example.com/2023/11/24/bilibili%E8%A7%86%E9%A2%91%E8%A7%A3%E6%9E%90%E4%B8%8B%E8%BD%BD-%E5%AD%97%E5%B9%95-%E5%8E%8B%E7%BC%A9/","excerpt":"","text":"视频解析 https://bili.iiilab.com/ bcc字幕下载 字幕 -&gt; 添加字幕 -&gt; 中文（中国）-&gt; 编辑 -&gt; 下载 bcc字幕转srt字幕 https://www.dreamlyn.cn/bsrt srt字幕是剪映支持的字幕格式 剪映合成字幕和视频 官方下载剪映即可 手动拖入即可，最后导出 QQ影音压缩 官方QQ影音已被下架 QQ影音下载 http://dldir1.qq.com/qqyy/pc/QQPlayer_Setup_39_936.exe 导入视频 -&gt; 影音工具箱 -&gt; 压缩 -&gt; 参数设置 -&gt; 开始压缩 压缩到20M以内，可以发送到微信","categories":[],"tags":[]},{"title":"aplayer实现音乐播放","slug":"aplayer音乐","date":"2023-09-07T12:24:27.000Z","updated":"2023-09-15T02:23:26.483Z","comments":true,"path":"2023/09/07/aplayer音乐/","link":"","permalink":"http://example.com/2023/09/07/aplayer%E9%9F%B3%E4%B9%90/","excerpt":"","text":"var _param = { getCustomPlayList: function () { const musicPage = document.getElementById(\"music-page\"); musicPage.innerHTML = ``; } }; _param.getCustomPlayList();","categories":[],"tags":[]},{"title":"Docker+Wordpress 搭建个人博客","slug":"Docker-Wordpress-搭建个人博客","date":"2023-09-02T11:49:49.000Z","updated":"2023-09-02T12:29:22.760Z","comments":true,"path":"2023/09/02/Docker-Wordpress-搭建个人博客/","link":"","permalink":"http://example.com/2023/09/02/Docker-Wordpress-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"Windows10示例 安装docker 在docker 官网选择Download for Windows。 更新WSL 1wsl --update 修改docker镜像为国内镜像 打开 Docker Desktop -&gt; 设置 -&gt; Docker Engine 修改并添加： 12&quot;experimental&quot; true,&quot;registry-mirrors&quot;: [&quot;https://yxzrazem.mirror.aliyuncs.com&quot;] 新建个人博客文件夹 12mkdir my_wordpress_blogcd my_wordpress_blog 建立docker-compose.yml文件，并添加内容 12345678910111213141516171819202122232425262728version: &#x27;3.3&#x27;services: db: image: mysql:5.7 volumes: - db_data:/var/lib/mysql restart: always environment: MYSQL_ROOT_PASSWORD: somewordpress MYSQL_DATABASE: wordpress MYSQL_USER: wordpress MYSQL_PASSWORD: wordpress wordpress: depends_on: - db image: wordpress:latest ports: - &quot;8000:80&quot; restart: always environment: WORDPRESS_DB_HOST: db:3306 WORDPRESS_DB_USER: wordpress WORDPRESS_DB_PASSWORD: wordpress WORDPRESS_DB_NAME: wordpressvolumes: db_data: &#123;&#125; 部署完成 1docker compose up -d 本地 localhost:8000 访问博客","categories":[],"tags":[]},{"title":"生疏单词收集","slug":"生疏单词收集","date":"2023-08-29T01:48:19.000Z","updated":"2023-09-15T02:36:53.099Z","comments":true,"path":"2023/08/29/生疏单词收集/","link":"","permalink":"http://example.com/2023/08/29/%E7%94%9F%E7%96%8F%E5%8D%95%E8%AF%8D%E6%94%B6%E9%9B%86/","excerpt":"","text":"英语单词收集 otherwise 否则 tutorial 教程 installation wizard 安装向导 ecosystem 生态系统 duplicate 重复的，复制的 efforts 努力 take on new responsibilities 承担新的责任 presence 存在，出现 constitute 组成，构成 endorsement (公开的)赞同，认可，支持，背书 entirely 完全地，全部地 even then 即使那样，即使这样 figure out 弄清楚 step through 单步执行 overview 概述 approximation 近似，近似值 peek definition 查看定义 potential 潜在的 scenarios 场景 semicolon 分号 preprocessor 预处理器 directive 指令 terminator 终止符 argument list 形参列表 parameter list 参数列表 original style 原创风格 very explicit style 非常明确的风格 manipulator 控制符 invalid 无效的，(法律上或官方)不承认的 carriage return 回车，换行 omitted 删除的，省略的 extensible 可扩展的 function prototype 函数原型 function 函数 procedure 过程 subroutine 子程序 toes 脚趾 absent from 缺席 stone 英石 (1 stone = 14 pounds) pound 磅 repositioning 重新定位 Celsius 摄氏的，摄氏 Fahrenheit 华氏的 astronomical 天文的 astronomical unit 天文单位 reserved 保留的 underscore 下划线(_) digit 数字 even more distinct 甚至更加明显 hyphen 连字符(-) yield 产生 developing 开发 shipping 发布 running 运行 infrastructure 基础设施 separate A from B 把A和B分开 deliver software 交付软件 in the same ways 用同样的方式 methodologies 方法论 significantly 显著地 delay 延迟 loosely 松散地 isolated 隔离的 container 容器 isolation 隔离 simultaneously 同时地 a hybrid of the two 两者地混合体 streamline the development lifecycle 简化开发生命周期 laptop 笔记本电脑 portability 可移植性 scaling up 扩展 tearing down 拆除 viable 可行的 cost-effective 经济高效的，性价比高的 density 密度 registry 注册表 template 模板 prior 事先的 exceed 超过 literal 字面意义的，字面量 definitely 明确地 mantissa 尾数 copyright 版权 Inc (incorporated 注册成立) 股份有限公司 foundation 基金会 warranty 担保 implied 不言而喻的，暗示的 merchantability 适销性 fitness 适合 granted （被）允许，准许，同意 arithmetic 算术 associativity 结合性 ditto 同上 foot 英尺 （1 foot = 12 inches) inch 英寸 illegal 非法的 mismatch 错配 feline 猫 penguin 企鹅 anonymous 匿名的 enumeration 枚举 enumerated type 枚举类型 enumerator 枚举量，枚举符 pointer arithmetic 指针算术 factorial 阶乘 prefix 前缀 postfix 后缀 comma 逗号 semicolon 分号 entry-condition 入口条件 exit-condition 出口条件 sentinel 哨兵 punctuation 标点符号 terminate 终止 sales 销售量 expenses 费用，开支 employee 雇员，雇工 in the industry 在行业中 the board of directors 董事会 lips 嘴唇 nails 指甲 sweatsuit 运动套服 mood 情绪，心情 period 句点，句号 numeric 数字的 non-numeric 非数字的 automobile 汽车 make and model 品牌和型号 odds 几率 cookies 曲奇饼 properties 财产，房地产，不动产 bottom-up programming 自下而上的程序设计 top-down programming 从上而下的程序设计 angle 角度 astronomical sights 天文景点 spring 春天 summer 夏天 fall 秋天 winter 冬天 season 季节 aliase 别名 wallet 钱包 rats 老鼠，耗子 rodents 啮齿动物，啮齿类 bunnies 兔子(bunny) cube 立方体 立方 evaluate 评价，评估 nonsensical 荒谬的 sensical 感官的 alter 改变 telescope 望远镜 focal length 焦距 eyepiece 目镜 function signature 函数特征标（函数参数列表） specialization 专业化，专门化，特化 instantiation 实例化，实例 template instantiation 模板实例 implicit instantiation 隐式实例化 overrides 优先于，压倒，推翻 general 一般的，总的，普遍的 explicit instantiation 显示实例化 explicit specialization 显示特化，显示具体化","categories":[],"tags":[]},{"title":"官网技术文档收集","slug":"官网技术文档收集","date":"2023-08-28T02:15:28.000Z","updated":"2024-10-11T00:18:35.615Z","comments":true,"path":"2023/08/28/官网技术文档收集/","link":"","permalink":"http://example.com/2023/08/28/%E5%AE%98%E7%BD%91%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%E6%94%B6%E9%9B%86/","excerpt":"","text":"官方网站+技术文档 LATEX LATEX 官网 LATEX 官方文档(英文) LATEX 官方文档(中文翻译) 在线LaTeX公式编辑器 在线Mathjax文档 HEXO HEXO 官网 HEXO 官方文档 Visual Studio Code VS code 官网 VS code 官方文档 Git Git 官网 Git 官方文档 CommonMarkdown CommonMark 官网 CommonMark 基本操作 VS code Markdown Markdown and Visual Studio Code hexo-theme-butterfly hexo-theme-butterfly Github hexo-theme-butterfly 官方文档 GitHub Flavored Markdown 的正式规范 GitHub Flavored Markdown 的正式规范 GitHub 风格的 Markdown 规范 docker docker 官网 docker 官方文档 待续","categories":[],"tags":[]},{"title":"Markdown常用语法","slug":"Markdown常用语法","date":"2023-08-06T12:58:46.000Z","updated":"2024-09-05T12:39:21.371Z","comments":true,"path":"2023/08/06/Markdown常用语法/","link":"","permalink":"http://example.com/2023/08/06/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/","excerpt":"","text":"一、Markdown简介 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。 Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。 Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。 Markdown 编写的文档后缀为 .md, .markdown。 Markdown 能被使用来撰写电子书，如：Gitbook。 当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge等。 Markdown编写Hello World!语法： 1# Hello World! 二、Markdown标题 使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。 使用#号标记标题语法格式： 1234567891011# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 显示效果： 一级标题 二级标题 三级标题 四级标题 五级标题 六级标题 三、Markdown段落 Markdown 的段落没有特殊的格式，直接编写文字就好，段落的换行号是使用两个以上的空格加回车。 3.1 字体 Markdown 可以使用以下几种字体： 用1个星号*或底线_表示斜体 用2个星号*或底线_表示粗体 用3个星号*或底线_表示粗斜体 语法格式： 1234567891011*斜体文字*_斜体文字_**粗体文字**__粗体文字__***粗斜体文字***___粗斜体文字___ 显示效果 斜体文字 斜体文字 粗体文字 粗体文字 粗斜体文字 粗斜体文字 3.2 分割线 可以在一行中用三个以上的星号*、减号-、底线_来建立一个分割线，行内不能有其他东西，你也可以在星号或减号蹭插入空格。下面这种写法都可以建立分隔线： 12345**** * *******- - ------- 显示效果： 3.3 删除线 如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线~~即可。 123baidu.comsina.com~~tencent.com~~ 显示效果如下： baidu.com sina.com tencent.com 3.4 下划线 下划线可以通过HTML的标签来实现 1&lt;u&gt;带下划线文本&lt;/u&gt; 显示效果如下： 带下划线文本 3.5 脚注 脚注是对文本的补充说明。 1[^要注明的文本]： 显示效果： [^要注明的文本]:input description here 四、Markdown 列表 4.1 有序列表和无序列表 Markdown支持有序列表和无序列表，无序列表使用星号(*)、加号(+)或者减号(-)作为标记： 1234567891011* 第一项* 第二项* 第三项+ 第一项+ 第二项+ 第三项- 第一项- 第二项- 第三项 显示效果： 第一项 第二项 第三项 第一项 第二项 第三项 第一项 第二项 第三项 有序列表直接在文字有加上1. 2. 3. 来表示，符号和文字之间加上一个空格字符，如： 1231. 第一项2. 第二项3. 第三项 第一项 第二项 第三项 4.2 列表嵌套 列表嵌套只需在子列表的选项前添加四个空格即可： 1234561. 第一项： - 第一项嵌套的第一个元素 - 第一项嵌套的第二个元素2. 第二项： - 第二项嵌套的第一个元素 - 第二项嵌套的第二个元素 显示效果： 第一项 第一项嵌套的第一个元素 第一项嵌套的第二个元素 第二项 第二项嵌套的第一个元素 第二项嵌套的第二个元素 五、Markdown区块 Markdown区块引用是在段落开头使用&gt;符号，然后后面紧跟一个空格符号。 123&gt; 区块引用&gt; Markdown教程&gt; 学的不仅是技术更是梦想 显示效果如下： 区块引用 Markdown教程 学的不仅是技术更是梦想 另外区块是可以嵌套的，一个&gt;符号是最外层，两个符号是第一层嵌套，以此类推： 123&gt; 最外层&gt;&gt; 第一层嵌套&gt;&gt;&gt; 第二层嵌套 显示效果如下： 最外层 第一层嵌套 第二层嵌套 5.1 区块中使用列表 区块中使用列表实例如下： 123456&gt; 区块中使用列表&gt; 1. 第一项&gt; 2. 第二项&gt; + 第一项&gt; + 第二项&gt; + 第三项 显示效果： 区块中使用列表 1. 第一项 2. 第二项 + 第一项 + 第二项 + 第三项 5.2 列表中使用区块 如果要在列表项目内放进区块，那么就需要在&gt;前添加四个空格和缩进。 1234- 第一项 &gt; Markdown教程 &gt; 学的不仅是技术更是梦想- 第二项 显示效果如下： 第一项 Markdown教程 学的不仅是技术更是梦想 第二项 六、Markdown代码框 如果是段落上的一个函数或片段的代码可以用两个`把它包起来。 1`print()`函数 print()函数 6.1 代码区块 代码区块使用4个空格或者一个制表符（Tab键）。 1234&lt;?Python print(&#x27;Markdown&#x27;) def test(): print(&#x27;Markdown test!&#x27;) 也可以用```包裹一段代码，并指定一种语言（也可以不指定）： 12345`` ``` ``(javascript)$(document).read(function()&#123; alert(&#x27;Markdown&#x27;);&#125;);`` ``` `` 显示效果： 123$(document).read(function()&#123; alert(&#x27;Markdown&#x27;);&#125;); 七、Markdown链接 链接方法使用如下 123[链接名称](链接地址)或者&lt;链接地址&gt; 例如： 12这是一个链接 [新浪新闻](https://news.sina.com.cn/)&lt;https://news.sina.com.cn/&gt; 显示效果如下： 这是一个链接 新浪新闻 https://news.sina.com.cn/ 7.1 高级链接 1234链接也可以用变量来代替，文档末尾附带变量地址：这个链接用1作为网址变量[baidu][1]这个链接用markdown作为网址变量[Markdown][markdown]然后文档的结尾为变量赋值(网址) 12[1]: http://www.baidu.com[markdown]: http://www.markdown.com 显示效果如下： 链接也可以用变量来代替，文档末尾附带变量地址： 这个链接用1作为网址变量baidu 这个链接用markdown作为网址变量Markdown 然后文档的结尾为变量赋值(网址) 八、Markdown图片 Markdown图片语法格式为： 12![alt 属性文本](图片地址)![alt 属性文本](图片地址 &quot;可选标题&quot;) 开头一个感叹号！ 接着一个方括号，里面放上图片的代替文字 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的‘title’属性文字。 示例如下： 1234![有问题上知乎 图标](https://cdn.staticaly.com/gh/WangShiSuiFeng24/picx-images-hosting@master/20230807/image.1oqer6reup34.webp)--- 显示效果如下： 也可以像网址那样对图片使用变量： 123这个图片链接用1作为网址变量[zhihu][1]然后在文档的结尾为变量赋值(网址)[1]:(https://cdn.staticaly.com/gh/WangShiSuiFeng24/picx-images-hosting@master/20230807/image.1oqer6reup34.webp) 显示效果如下： 这个图片用1作为网址变量zhihu 然后在文档的结尾为变量赋值(网址) Markdown 没有办法指定图片的高度与宽度，如果需要的话，可以使用普通的标签。 1&lt;img src=&quot;https://cdn.staticaly.com/gh/WangShiSuiFeng24/picx-images-hosting@master/20230807/image.1oqer6reup34.webp&quot; width=10%&gt; 显示效果： 九、Markdown表格 Markdown制作表格使用|来分隔不同的单元格，使用-来分隔表头和其他行。 语法格式： 1234|表头1|表头2||----|----||单元格11|单元格12||单元格21|单元格22| 表头1 表头2 单元格11 单元格12 单元格21 单元格22 9.1 对齐方式 可以设置表头的对齐方式： -: 设置内容或标题栏右对齐 :- 设置内容或标题栏左对齐 :-: 设置内容或标题栏居中对齐 语法格式： 1234|左对齐|居中对齐|右对齐||:----|:----:|----:||单元格11|单元格12|单元格13||单元格21|单元格22|单元格23| 左对齐 居中对齐 右对齐 单元格11 单元格12 单元格13 单元格21 单元格22 单元格23 十、Markdown高级技巧 支持的HTML元素 不在Markdown涵盖范围之类的标签，都可以直接在文档里面用HTML撰写。 如： 1使用&lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt;重启电脑 显示效果如下： 使用Ctrl+Alt+Del重启电脑 10.1 转义 Markdown使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown使用反斜杠转义特殊字符： 12**文本加粗**\\*\\*正常显示星号\\*\\* 显示效果： 文本加粗 **正常显示星号** Markdown支持一下这些符号前面加上反斜杠来帮助插入普通符号： 1234567891011\\ 反斜线` 反引号* 星号_ 下划线&#123;&#125; 花括号[] 方括号() 小括号+ 加号- 减号. 英文句点! 感叹号 10.2 数学公式 当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。 示例如下： 123$$\\int_0^1 &#123;x^2&#125; \\,&#123;\\rm d&#125;x$$ 显示效果： ∫01x2 dx\\int_0^1 {x^2} \\,{\\rm d}x ∫01​x2dx 参考链接 CommonMark VS code Markdown 在线Markdown编辑器 在线LaTeX公式编辑器","categories":[],"tags":[]},{"title":"待买书籍","slug":"待买书籍","date":"2023-08-04T14:25:50.000Z","updated":"2023-08-04T14:55:39.489Z","comments":true,"path":"2023/08/04/待买书籍/","link":"","permalink":"http://example.com/2023/08/04/%E5%BE%85%E4%B9%B0%E4%B9%A6%E7%B1%8D/","excerpt":"","text":"Python: ​ Python从入门到实践 ​ Python核心编程 Java核心技术(两卷,这个简单一点) 算法: ​ 算法 计算机网络: ​ TCP/IP协议栈 Linux: ​ Unix环境高级编程(企业级别C) JavaEE框架: ​ Spring 实战 ​ SpringBoot实战 ​ Spring技术内幕 数据库: ​ MySQL必知必会 ​ 提升: ​ 高性能MySQL 代码质量: ​ 重构改善既有代码的设计","categories":[],"tags":[]},{"title":"centos7 使用hexo框架搭建博客成功","slug":"centos7-使用hexo框架搭建博客成功","date":"2023-08-04T12:44:11.741Z","updated":"2023-08-26T06:44:38.528Z","comments":true,"path":"2023/08/04/centos7-使用hexo框架搭建博客成功/","link":"","permalink":"http://example.com/2023/08/04/centos7-%E4%BD%BF%E7%94%A8hexo%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%88%90%E5%8A%9F/","excerpt":"","text":"1、安装git yum install git -y 2、使用wget下载nodejs 16.15.0版本的压缩包 wget https://nodejs.org/dist/v16.15.0/node-v16.15.0-linux-x64.tar.gz 3、解压缩node-v16.15.0到当前文件夹 tar -zxvf node-v16.15.0-linux-x64.tar.gz 4、移动解压后的node-v16.15.0到/urs/local/bin 目录下，并改名为node mv node-v16.15.0-linux-x64 /usr/local/bin cd /usr/local/bin mv node-v16.15.0-linux-x64 node 5、更改环境变量 vim /etc/profile 末尾添加： export NODE_HOME=/usr/local/bin/node export PATH=$PATH:$NODE_HOME/bin 6、更新环境变量 source /etc/profile 7、检查node、npm是否安装配置成功 node -v npm -v 8、使用npm安装cnpm npm install -g cnpm --registry=https://registry.npm.taobao.org cnpm -v 9、使用cnpm安装hexo cnpm install -g hexo-cli hexo -v 10、开始使用hexo框架，初始化博客目录 cd ~ mkdir blog cd blog hexo init 11、需要防火墙打开4000端口 firewall-cmd --zone=public --add-port=4000/tcp --permanent firewall-cmd --reload 12、启动hexo服务，恭喜你成功搭建成功 hexo s 参考链接 hexo 官方文档","categories":[],"tags":[]},{"title":"我的第一篇博客文章","slug":"我的第一篇博客文章","date":"2023-08-01T12:46:10.000Z","updated":"2024-10-18T01:07:14.747Z","comments":true,"path":"2023/08/01/我的第一篇博客文章/","link":"","permalink":"http://example.com/2023/08/01/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/","excerpt":"","text":"第一章 内容修改 第二章 内容 参考文献 https://www.codesheep.com","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2023-08-01T12:38:57.802Z","updated":"2023-08-01T12:38:57.803Z","comments":true,"path":"2023/08/01/hello-world/","link":"","permalink":"http://example.com/2023/08/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}